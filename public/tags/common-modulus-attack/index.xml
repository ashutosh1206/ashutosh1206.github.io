<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Common-Modulus-Attack on Ash's blog</title><link>https://ashutosh1206.github.io/tags/common-modulus-attack/</link><description>Recent content in Common-Modulus-Attack on Ash's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 17 Dec 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://ashutosh1206.github.io/tags/common-modulus-attack/index.xml" rel="self" type="application/rss+xml"/><item><title>RSA 1s Fun - InCTFi 2017</title><link>https://ashutosh1206.github.io/ctf/inctfi17-rsaisfun/</link><pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/inctfi17-rsaisfun/</guid><description>&lt;p>&lt;strong>Challenge Points&lt;/strong>: 150&lt;br>
&lt;strong>Challenge Description&lt;/strong>: Mathematics and Crypto make a deadly combination!&lt;/p>
&lt;p>Intended solution!&lt;/p>
&lt;p>The challenge, as the description suggests, involves applying mathematics to solve the RSA based encryption system. The encryption script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> Crypto.Util.number &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>e1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>e2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">prime_gen&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p &lt;span style="color:#f92672">=&lt;/span> getPrime(&lt;span style="color:#ae81ff">1024&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q &lt;span style="color:#f92672">=&lt;/span> getPrime(&lt;span style="color:#ae81ff">1024&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">*&lt;/span>q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phin &lt;span style="color:#f92672">=&lt;/span> (p&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>(q&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> GCD(e1, phin) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">and&lt;/span> GCD(e2, phin) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (p, q, n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>p, q, n &lt;span style="color:#f92672">=&lt;/span> prime_gen()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#34;p: &amp;#34;&lt;/span>, p
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#34;q: &amp;#34;&lt;/span>, q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#34;n: &amp;#34;&lt;/span>, n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flag &lt;span style="color:#f92672">=&lt;/span> bytes_to_long(open(&lt;span style="color:#e6db74">&amp;#34;flag.txt&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read()&lt;span style="color:#f92672">.&lt;/span>strip())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">assert&lt;/span> flag &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#66d9ef">assert&lt;/span> flag&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c1 &lt;span style="color:#f92672">=&lt;/span> pow(flag, e1, n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c2 &lt;span style="color:#f92672">=&lt;/span> pow(flag, e2, n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#34;c1: &amp;#34;&lt;/span>, c1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print &lt;span style="color:#e6db74">&amp;#34;c2: &amp;#34;&lt;/span>, c2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Two different public key exponents \(e_1 = 9\) and \(e_2 = 123\) are being used to encrypt the same message and generate ciphertexts \(c_1\) and \(c_2\) respectively. By &lt;a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean Algorithm&lt;/a>, we can calculate coefficients of Bezout&amp;rsquo;s identity \(a, b\) as:&lt;br>
$$e_1*a + e_2*b = gcd(e_1, e_2)$$
$$(9*14) + (123*(-1)) = 3$$&lt;/p></description></item></channel></rss>