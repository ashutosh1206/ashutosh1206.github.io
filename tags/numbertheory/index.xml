<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>NumberTheory on Ashutosh Ahelleya</title><link>https://ashutosh1206.github.io/tags/numbertheory/</link><description>Recent content in NumberTheory on Ashutosh Ahelleya</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 29 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://ashutosh1206.github.io/tags/numbertheory/index.xml" rel="self" type="application/rss+xml"/><item><title>waRSAw - InCTFi 2019</title><link>https://ashutosh1206.github.io/ctf/inctfi19-warsaw/</link><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/inctfi19-warsaw/</guid><description>&lt;p>Intended solution of waRSAw challenge from InCTF Internationals 2019&lt;/p>
&lt;p>tl;dr variant of LSB Oracle Attack on unpadded RSA&lt;/p></description></item><item><title>EZDSA - Midnight Sun CTF Quals</title><link>https://ashutosh1206.github.io/ctf/midnightsunquals19-ezdsa/</link><pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/midnightsunquals19-ezdsa/</guid><description>Challenge Points: 223
Challenge Description:
Someone told me not to use DSA, so I came up with this.
In this challenge, we are given a script that signs any message given as an input:
class PrivateSigningKey: def __init__(self): self.gen = 0x44120dc98545c6d3d81bfc7898983e7b7f6ac8e08d3943af0be7f5d52264abb3775a905e003151ed0631376165b65c8ef72d0b6880da7e4b5e7b833377bb50fde65846426a5bfdc182673b6b2504ebfe0d6bca36338b3a3be334689c1afb17869baeb2b0380351b61555df31f0cda3445bba4023be72a494588d640a9da7bd16L self.q = 0x926c99d24bd4d5b47adb75bd9933de8be5932f4bL self.p = 0x80000000000001cda6f403d8a752a4e7976173ebfcd2acf69a29f4bada1ca3178b56131c2c1f00cf7875a2e7c497b10fea66b26436e40b7b73952081319e26603810a558f871d6d256fddbec5933b77fa7d1d0d75267dcae1f24ea7cc57b3a30f8ea09310772440f016c13e08b56b1196a687d6a5e5de864068f3fd936a361c5L self.key = int(FLAG.encode(&amp;#34;hex&amp;#34;), 16) def sign(self, m): def bytes_to_long(b): return long(b.encode(&amp;#34;hex&amp;#34;), 16) h = bytes_to_long(sha1(m).digest()) u = bytes_to_long(Random.new().read(20)) assert(bytes_to_long(m) % (self.q - 1) !</description></item><item><title>Daring - Hxp CTF</title><link>https://ashutosh1206.github.io/ctf/hxp18-daring/</link><pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/hxp18-daring/</guid><description>Challenge Points:
Challenge Description:
We encrypted our flag, but we lost the keys. Can you help?
This was a simple yet a very tricky challenge aimed at testing Number Theory basics. In this challenge we are given a small script:
#!/usr/bin/env python3 import os from Crypto.Cipher import AES from Crypto.Hash import SHA256 from Crypto.Util import Counter from Crypto.PublicKey import RSA flag = open(&amp;#39;flag.txt&amp;#39;, &amp;#39;rb&amp;#39;).read().strip() key = RSA.generate(1024, e=3) open(&amp;#39;pubkey.txt&amp;#39;, &amp;#39;w&amp;#39;).write(key.publickey().exportKey(&amp;#39;PEM&amp;#39;).decode() + &amp;#39;\n&amp;#39;) open(&amp;#39;rsa.</description></item><item><title>OPEC - ASIS CTF Quals</title><link>https://ashutosh1206.github.io/ctf/asisquals18-opec/</link><pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/asisquals18-opec/</guid><description>Challenge Points: 207
Challenge Description:
We like the OPEC, but not oily one!
This challenge is an Okamotoâ€“Uchiyama cryptosystem. Let us see how encryption/decryption takes place in this public key cryptosystem.
Okamoto Uchiyama Cryptosystem 101 Key Generation, Encryption and Decryption take place as follows (pasted from Wikipedia): We will see how the decryption formula gives us the message and hence prove it. We want to prove that:
$$\frac{L(C^{p-1}\mod p^2)}{L(g^{p-1}\mod p^2)} = m \mod p$$ where \(L(x) = \frac{x-1}{p}\)</description></item><item><title>UncleSam - ASIS CTF Quals</title><link>https://ashutosh1206.github.io/ctf/asisquals18-unclesam/</link><pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/asisquals18-unclesam/</guid><description>Challenge Points: 123
Challenge Description:
Uncle Sam needs your help!
The given challenge is a Schmidt-Samoa cryptosystem. Let us look at how encryption/decryption takes place in this public key cryptosystem and then move to solving the challenge.
Schmidt-Samoa Cryptosystem 101 Two large primes p and q are chosen randomly, and the modulus is calculated: \(N = p*p*q\). The private key is calculated as \(d \equiv e^{-1} \mod lcm(p-1, q-1)\). The modulus is the public key too.</description></item><item><title>RSA-Padding - N1CTF</title><link>https://ashutosh1206.github.io/ctf/n1ctf18-rsa-padding/</link><pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/n1ctf18-rsa-padding/</guid><description>Challenge Points: 303
Challenge is running on the service: nc 47.75.39.249 23333
After surpassing the Proof of Work, we get the following challenge: On selecting the option get code, we get the following code that is being used for encryption:
#!/usr/bin/env python3 # -*- coding=utf-8 -*- from Crypto.Util.number import getPrime, GCD, bytes_to_long from hashlib import sha256 import random import signal import sys, os signal.alarm(20) m = b&amp;#34;xxxxxxxxxxxxxx&amp;#34; n = 21727106551797231400330796721401157037131178503238742210927927256416073956351568958100038047053002307191569558524956627892618119799679572039939819410371609015002302388267502253326720505214690802942662248282638776986759094777991439524946955458393011802700815763494042802326575866088840712980094975335414387283865492939790773300256234946983831571957038601270911425008907130353723909371646714722730577923843205527739734035515152341673364211058969041089741946974118237091455770042750971424415176552479618605177552145594339271192853653120859740022742221562438237923294609436512995857399568803043924319953346241964071252941 e = 3 def proof(): strings = &amp;#34;abcdefghijklmnopqrstuvwxyzWOERFJASKL&amp;#34; prefix = &amp;#34;&amp;#34;.</description></item><item><title>Simpler Than RSA - MeePwn CTF</title><link>https://ashutosh1206.github.io/ctf/meepwn17-simpler-than-rsa/</link><pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/meepwn17-simpler-than-rsa/</guid><description>Challenge Points: 100
We are given an encryption script simple.py:
Other than the ciphertext, values of n, g, h are also public. The following function is used to generate values for the challenge:
def generate(nbits): p = getPrime(nbits) q = getPrime(nbits) n = p * q * p g = random.randint(1, n) h = pow(g, n, n) return (n, g, h) The encryption function:
def encrypt(m, n, g, h): r = random.</description></item><item><title>BabyRSA - Codegate Preliminary CTF</title><link>https://ashutosh1206.github.io/ctf/codegatepre18-babyrsa/</link><pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/codegatepre18-babyrsa/</guid><description>Challenge Points: 349
The idea behind the challenge involved knowledge of basic Number Theory which was pretty cool!
We are given an encryption script and public key parameters that are used for encrypting a message. Everything in the script works normally except the GenerateKeys function:
def GenerateKeys(p, q): e = 65537 n = p * q pi_n = (p-1)*(q-1) d = mulinv(e, pi_n) h = (d+p)^(d-p) g = d*(p-0xdeadbeef) return [e, n, h, g] There is are two extra variables other than the regular public key parameters whose values are known: g and h</description></item><item><title>DLP - ASIS CTF Quals</title><link>https://ashutosh1206.github.io/ctf/asisquals18-dlp/</link><pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/asisquals18-dlp/</guid><description>Challenge Points: 158
Ciphertext is generated as following:
def encrypt(nbit, msg): msg = bytes_to_long(msg) p = getPrime(nbit) q = getPrime(nbit) n = p*q s = getPrime(4) enc = pow(n+1, msg, n**(s+1)) return n, enc We have: \((n+1)^{msg}\mod n^{s+1}\)
Expanding the above equation Binomially, we get:
$$\binom{msg}{0}n^{msg} + \binom{msg}{1}n^{msg-1} + \binom{msg}{2}n^{msg-2} + &amp;hellip; + \binom{msg}{msg-1}n + \binom{msg}{msg}n^0$$ $$(\binom{msg}{0}n^{msg-2} + \binom{msg}{1}n^{msg-3} + &amp;hellip; + \binom{msg}{2})n^2 + \binom{msg}{msg-1}n + \binom{msg}{msg}n^0$$ This can be written as: \((x)n^2 + mn + 1\), where</description></item><item><title>Prime Enigma - Hack.lu CTF</title><link>https://ashutosh1206.github.io/ctf/hacklu17-prime-enigma/</link><pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate><guid>https://ashutosh1206.github.io/ctf/hacklu17-prime-enigma/</guid><description>Challenge Points: 50(+100)
Challenge Description:
Hey there fellow lizard how nice of you to drop by! Did you know those filthy humans really think that some numbers have special meanings? Seven, 13 and for some strange reason even 9000. Go and show them that a good prime does not make a secure cryptosystem!
Given encryption script:
g = 5 d = key m = int(flag.encode(&amp;#39;hex&amp;#39;), 16) % p B = pow(g, d, p) # Equation-1 k = pow(A, d, p) # Equation-2 c = k * m % p # Equation-3 Values p, A, g, B, c are known.</description></item></channel></rss>