<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gracias - ASIS CTF Finals | Ashutosh Ahelleya</title><meta name=keywords content="RSA"><meta name=description content="Challenge Points: 297
Challenge Solves: 9
Challenge Description:
Some people think that combination of cryptographic systems will definitely improve the security. That’s your turn to prove them wrong.
This is a multi-prime RSA challenge where we are given an encryption script, which has two functions:
Generating public and private keys - make_pubpri Encrypting data using the public key generated from the first function - encrypt Preliminary Analysis: make_pubpri function Function generating public and private keys:"><meta name=author content="Ashutosh Ahelleya"><link rel=canonical href=https://ashutosh1206.github.io/ctf/asisfinals-gracias/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ashutosh1206.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ashutosh1206.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ashutosh1206.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ashutosh1206.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ashutosh1206.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Gracias - ASIS CTF Finals"><meta property="og:description" content="Challenge Points: 297
Challenge Solves: 9
Challenge Description:
Some people think that combination of cryptographic systems will definitely improve the security. That’s your turn to prove them wrong.
This is a multi-prime RSA challenge where we are given an encryption script, which has two functions:
Generating public and private keys - make_pubpri Encrypting data using the public key generated from the first function - encrypt Preliminary Analysis: make_pubpri function Function generating public and private keys:"><meta property="og:type" content="article"><meta property="og:url" content="https://ashutosh1206.github.io/ctf/asisfinals-gracias/"><meta property="article:section" content="ctf"><meta property="article:published_time" content="2017-11-24T00:00:00+00:00"><meta property="article:modified_time" content="2017-11-24T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gracias - ASIS CTF Finals"><meta name=twitter:description content="Challenge Points: 297
Challenge Solves: 9
Challenge Description:
Some people think that combination of cryptographic systems will definitely improve the security. That’s your turn to prove them wrong.
This is a multi-prime RSA challenge where we are given an encryption script, which has two functions:
Generating public and private keys - make_pubpri Encrypting data using the public key generated from the first function - encrypt Preliminary Analysis: make_pubpri function Function generating public and private keys:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Ctfs","item":"https://ashutosh1206.github.io/ctf/"},{"@type":"ListItem","position":2,"name":"Gracias - ASIS CTF Finals","item":"https://ashutosh1206.github.io/ctf/asisfinals-gracias/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gracias - ASIS CTF Finals","name":"Gracias - ASIS CTF Finals","description":"Challenge Points: 297\nChallenge Solves: 9\nChallenge Description:\nSome people think that combination of cryptographic systems will definitely improve the security. That’s your turn to prove them wrong.\nThis is a multi-prime RSA challenge where we are given an encryption script, which has two functions:\nGenerating public and private keys - make_pubpri Encrypting data using the public key generated from the first function - encrypt Preliminary Analysis: make_pubpri function Function generating public and private keys:","keywords":["RSA"],"articleBody":"Challenge Points: 297\nChallenge Solves: 9\nChallenge Description:\nSome people think that combination of cryptographic systems will definitely improve the security. That’s your turn to prove them wrong.\nThis is a multi-prime RSA challenge where we are given an encryption script, which has two functions:\nGenerating public and private keys - make_pubpri Encrypting data using the public key generated from the first function - encrypt Preliminary Analysis: make_pubpri function Function generating public and private keys:\ndef make_pubpri(nbit): p, q, r = [ getPrime(nbit) for _ in xrange(3)] n = p * q * r phi = (p-1)*(q-1)*(r-1) l = min([p, q, r]) d = getPrime(1) e = inverse(d, phi) a = gensafeprime.generate(2*nbit) while True: g = getRandomRange(2, a) if pow(g, 2, a) != 1 and pow(g, a/2, a) != 1: break return (n, e, a, g), (n, d, a, g) Observations:\nInstead of two, there are three 512-bit-primes: p, q, r generated in this RSA encryption. Decryption exponent d, is generated as a 256-bit prime. The function returns n, e, a, g as the public key. Preliminary Analysis: encrypt function def encrypt(m, pub): n, e, a, g = pub k = getRandomRange(2, a) K = pow(g, k, a) c1, c2 = pow(k, e, n), (m * K) % a return c1, c2 \\(K = g^k\\mod a\\)\nUnlike the conventional RSA encryption, here the message is not encrypted using RSA, instead of that, k is encrypted using the public key exponent e, the ciphertext of which is \\(c_1\\):\n\\(c_1 = k^e\\mod n\\)\nThere is another ciphertext variable returned in the function along with \\(c_1\\) that is \\(c_2\\):\n\\(c_2 = (m*K)\\mod a\\)\nFlow of solution Decrypt the ciphertext \\(c_1\\) to get k Use this k to generate K as discussed in the previous section Multiply \\(c_2\\) with modular multiplicative inverse of K over a, to get the message m \\(m \\equiv c_2*K^{-1}\\mod a\\) Decrypting ciphertext \\(c_1\\) Here are values of public key given:\nn = 1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L e = 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L The first thought that would come to one’s mind is to get the corresponding private key using Wiener’s Attack.\nCriteria for a public key to be vulnerable to Wiener’s Attack:\n\\(d\u003c((1 / 3)*n^{1 / 4})\\) or \\(e \u003e n^{3 / 2}\\)\nI found that e given in the challenge is a few bits smaller than \\(n^{3 / 2}\\), which led to a conclusion that d, i.e. the private key exponent, must be a few bits greater than \\(d\u003c((1 / 3)*n^{1 / 4})\\)\nThe given values fail to fall under conventional criteria of Wiener’s Attack, but only by a few bits, which is kind of shady. Anyway, I wrote this script implementing Wiener’s Attack in python-sage to see if I find any luck:\nfrom sage.all import continued_fraction, Integer def wiener(e, n): m = 12345 c = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) m1 = pow(c, d, n) if m1 == m: return d pubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L) n, e, a, g = pubkey print wiener(e, n) As expected, the function did not return anything. I couldn’t find any other vulnerability in the code except the Wiener’s Attack and the close values of e and n suggested that there must be some kind of a Wiener’s Attack vulnerability, although not the conventional one.\nA variant of Wiener’s attack on RSA There is a paper by Andrej Dujella on a variant of Wiener’s Attack. It also works well when the size of d is just a few bits greater than \\(N^{1 / 4}\\)\nYou can read the paper here: A variant of Wiener’s Attack on RSA\nHere is a conclusion of the paper which is significant in our attack:\nAlong with decryption exponent d being a denominator of the convergent of the continued fraction of (e/n), d can also be written in the form:\n\\(d = rq_{m+1} + sq_m\\)\n\\(q_{m+1}\\) \u0026 \\(q_m\\) are (m+1)th and mth denominators respectively, of convergents of the continued fraction of (e/n).\nDecrypting ciphertext \\(c_1\\) (cont.) I assigned \\(q_0\\) = 0 and \\(q_1\\) as the first denominator of convergent of continued fraction of (e/n).\nHere is the exploit where the variant of Wiener’s Attack is implemented:\nfrom sage.all import continued_fraction, Integer def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() q1 = i.denominator() for r in range(20): for s in range(20): d = r*q1 + s*q0 m1 = pow(c, d, n) if m1 == m: return d q0 = q1 pubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L) c = (1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773L, 139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827L) n, e, a, g = pubkey c1, c2 = c d = wiener(e, n) print d Running the above script gave out the private key exponent:\nd = 100556095937036905102538523179832446199526507742826168666218687736467897968451 Computing \\(K\\) and getting the flag Now that we have d, we can get the flag by simply running the below script:\nfrom Crypto.Util.number import * k = pow(c1, d, n) K = pow(g, k, a) print long_to_bytes(c2 * inverse(K, a) % a) Flag: ASIS{Wiener_at7ack_iN_mUlt1_Prim3_RSA_iZ_f34sible_t0O!}\nYou can read the full solution script here\nReferences Niklasb’s solution ","wordCount":"853","inLanguage":"en","datePublished":"2017-11-24T00:00:00Z","dateModified":"2017-11-24T00:00:00Z","author":{"@type":"Person","name":"Ashutosh Ahelleya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ashutosh1206.github.io/ctf/asisfinals-gracias/"},"publisher":{"@type":"Organization","name":"Ashutosh Ahelleya","logo":{"@type":"ImageObject","url":"https://ashutosh1206.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ashutosh1206.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ashutosh1206.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ashutosh1206.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://ashutosh1206.github.io/ctf/ title=CTF><span>CTF</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Gracias - ASIS CTF Finals</h1><div class=post-meta><span title='2017-11-24 00:00:00 +0000 UTC'>November 24, 2017</span>&nbsp;·&nbsp;Ashutosh Ahelleya</div></header><div class=post-content><p><strong>Challenge Points</strong>: 297<br><strong>Challenge Solves</strong>: 9<br><strong>Challenge Description</strong>:</p><blockquote><p>Some people think that combination of cryptographic systems will definitely improve the security.
That’s your turn to prove them wrong.</p></blockquote><p>This is a multi-prime RSA challenge where we are given an encryption script, which has two functions:</p><ol><li>Generating public and private keys - <code>make_pubpri</code></li><li>Encrypting data using the public key generated from the first function - <code>encrypt</code></li></ol><h2 id=preliminary-analysis-make_pubpri-function>Preliminary Analysis: <code>make_pubpri</code> function<a hidden class=anchor aria-hidden=true href=#preliminary-analysis-make_pubpri-function>#</a></h2><p>Function generating public and private keys:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_pubpri</span>(nbit):
</span></span><span style=display:flex><span>    p, q, r <span style=color:#f92672>=</span> [ getPrime(nbit) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> xrange(<span style=color:#ae81ff>3</span>)]
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> p <span style=color:#f92672>*</span> q <span style=color:#f92672>*</span> r
</span></span><span style=display:flex><span>    phi <span style=color:#f92672>=</span> (p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span>(q<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span>(r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    l <span style=color:#f92672>=</span> min([p, q, r])
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> getPrime(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    e <span style=color:#f92672>=</span> inverse(d, phi)
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> gensafeprime<span style=color:#f92672>.</span>generate(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>nbit)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        g <span style=color:#f92672>=</span> getRandomRange(<span style=color:#ae81ff>2</span>, a)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> pow(g, <span style=color:#ae81ff>2</span>, a) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> pow(g, a<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, a) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (n, e, a, g), (n, d, a, g)
</span></span></code></pre></div><p><strong>Observations</strong>:</p><ol><li>Instead of two, there are three 512-bit-primes: <code>p</code>, <code>q</code>, <code>r</code> generated in this RSA encryption.</li><li>Decryption exponent <code>d</code>, is generated as a 256-bit prime.</li><li>The function returns <code>n</code>, <code>e</code>, <code>a</code>, <code>g</code> as the public key.</li></ol><h2 id=preliminary-analysis-encrypt-function>Preliminary Analysis: <code>encrypt</code> function<a hidden class=anchor aria-hidden=true href=#preliminary-analysis-encrypt-function>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encrypt</span>(m, pub):
</span></span><span style=display:flex><span>    n, e, a, g <span style=color:#f92672>=</span> pub
</span></span><span style=display:flex><span>    k <span style=color:#f92672>=</span> getRandomRange(<span style=color:#ae81ff>2</span>, a)
</span></span><span style=display:flex><span>    K <span style=color:#f92672>=</span> pow(g, k, a)
</span></span><span style=display:flex><span>    c1, c2 <span style=color:#f92672>=</span> pow(k, e, n), (m <span style=color:#f92672>*</span> K) <span style=color:#f92672>%</span> a
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> c1, c2
</span></span></code></pre></div><p>\(K = g^k\mod a\)</p><p>Unlike the conventional RSA encryption, here the message is not encrypted using RSA, instead of that, <code>k</code> is encrypted using the public key exponent <code>e</code>, the ciphertext of which is \(c_1\):<br>\(c_1 = k^e\mod n\)</p><p>There is another ciphertext variable returned in the function along with \(c_1\) that is \(c_2\):<br>\(c_2 = (m*K)\mod a\)</p><h2 id=flow-of-solution>Flow of solution<a hidden class=anchor aria-hidden=true href=#flow-of-solution>#</a></h2><ol><li>Decrypt the ciphertext \(c_1\) to get <code>k</code></li><li>Use this <code>k</code> to generate <code>K</code> as discussed in the previous section</li><li>Multiply \(c_2\) with modular multiplicative inverse of <code>K</code> over <code>a</code>, to get the message <code>m</code><ul><li>\(m \equiv c_2*K^{-1}\mod a\)</li></ul></li></ol><h2 id=decrypting-ciphertext-c_1>Decrypting ciphertext \(c_1\)<a hidden class=anchor aria-hidden=true href=#decrypting-ciphertext-c_1>#</a></h2><p>Here are values of public key given:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567</span>L
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>e <span style=color:#f92672>=</span> <span style=color:#ae81ff>814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451</span>L
</span></span></code></pre></div><p>The first thought that would come to one&rsquo;s mind is to get the corresponding private key using Wiener’s Attack.</p><p>Criteria for a public key to be vulnerable to Wiener’s Attack:<br>\(d&lt;((1 / 3)*n^{1 / 4})\) or \(e > n^{3 / 2}\)</p><p>I found that <code>e</code> given in the challenge is a few bits smaller than \(n^{3 / 2}\), which led to a conclusion that <code>d</code>, i.e. the private key exponent, must be a few bits greater than \(d&lt;((1 / 3)*n^{1 / 4})\)</p><p>The given values fail to fall under conventional criteria of Wiener’s Attack, but only by a few bits, which is kind of shady. Anyway, I wrote this script implementing Wiener’s Attack in python-sage to see if I find any luck:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> sage.all <span style=color:#f92672>import</span> continued_fraction, Integer
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wiener</span>(e, n):
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> <span style=color:#ae81ff>12345</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> pow(m, e, n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    list1 <span style=color:#f92672>=</span> continued_fraction(Integer(e)<span style=color:#f92672>/</span>Integer(n))
</span></span><span style=display:flex><span>    conv <span style=color:#f92672>=</span> list1<span style=color:#f92672>.</span>convergents()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> conv:
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> int(i<span style=color:#f92672>.</span>denominator())
</span></span><span style=display:flex><span>        m1 <span style=color:#f92672>=</span> pow(c, d, n)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> m1 <span style=color:#f92672>==</span> m:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> d
</span></span><span style=display:flex><span>pubkey <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722</span>L)
</span></span><span style=display:flex><span>n, e, a, g <span style=color:#f92672>=</span> pubkey
</span></span><span style=display:flex><span>print wiener(e, n)
</span></span></code></pre></div><p>As expected, the function did not return anything. I couldn&rsquo;t find any other vulnerability in the code except the Wiener’s Attack and the close values of <code>e</code> and <code>n</code> suggested that there must be some kind of a Wiener’s Attack vulnerability, although not the conventional one.</p><h2 id=a-variant-of-wieners-attack-on-rsa>A variant of Wiener&rsquo;s attack on RSA<a hidden class=anchor aria-hidden=true href=#a-variant-of-wieners-attack-on-rsa>#</a></h2><p>There is a paper by Andrej Dujella on a variant of Wiener’s Attack. It also works well when the size of <code>d</code> is just a few bits greater than \(N^{1 / 4}\)</p><p>You can read the paper here: <a href=https://www.math.tugraz.at/~cecc08/abstracts/cecc08_abstract_20.pdf>A variant of Wiener&rsquo;s Attack on RSA</a></p><p>Here is a conclusion of the paper which is significant in our attack:</p><blockquote><p>Along with decryption exponent <code>d</code> being a denominator of the convergent of the continued fraction of (e/n), <code>d</code> can also be written in the form:</p><p>\(d = r<em>q_{m+1} + s</em>q_m\)</p></blockquote><p>\(q_{m+1}\) & \(q_m\) are (m+1)th and mth denominators respectively, of convergents of the continued fraction of (e/n).</p><h2 id=decrypting-ciphertext-c_1-cont>Decrypting ciphertext \(c_1\) (cont.)<a hidden class=anchor aria-hidden=true href=#decrypting-ciphertext-c_1-cont>#</a></h2><p>I assigned \(q_0\) = 0 and \(q_1\) as the first denominator of convergent of continued fraction of (e/n).</p><p>Here is the exploit where the variant of Wiener&rsquo;s Attack is implemented:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> sage.all <span style=color:#f92672>import</span> continued_fraction, Integer
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wiener</span>(e, n):
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> <span style=color:#ae81ff>12345</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> pow(m, e, n)
</span></span><span style=display:flex><span>    q0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    list1 <span style=color:#f92672>=</span> continued_fraction(Integer(e)<span style=color:#f92672>/</span>Integer(n))
</span></span><span style=display:flex><span>    conv <span style=color:#f92672>=</span> list1<span style=color:#f92672>.</span>convergents()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> conv:
</span></span><span style=display:flex><span>        k <span style=color:#f92672>=</span> i<span style=color:#f92672>.</span>numerator()
</span></span><span style=display:flex><span>        q1 <span style=color:#f92672>=</span> i<span style=color:#f92672>.</span>denominator()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> r <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>20</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>20</span>):
</span></span><span style=display:flex><span>                d <span style=color:#f92672>=</span> r<span style=color:#f92672>*</span>q1 <span style=color:#f92672>+</span> s<span style=color:#f92672>*</span>q0
</span></span><span style=display:flex><span>                m1 <span style=color:#f92672>=</span> pow(c, d, n)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> m1 <span style=color:#f92672>==</span> m:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> d
</span></span><span style=display:flex><span>        q0 <span style=color:#f92672>=</span> q1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pubkey <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722</span>L)
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773</span>L,
</span></span><span style=display:flex><span><span style=color:#ae81ff>139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827</span>L)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n, e, a, g <span style=color:#f92672>=</span> pubkey
</span></span><span style=display:flex><span>c1, c2 <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> wiener(e, n)
</span></span><span style=display:flex><span>print d
</span></span></code></pre></div><p>Running the above script gave out the private key exponent:</p><pre tabindex=0><code>d = 100556095937036905102538523179832446199526507742826168666218687736467897968451
</code></pre><h2 id=computing-k-and-getting-the-flag>Computing \(K\) and getting the flag<a hidden class=anchor aria-hidden=true href=#computing-k-and-getting-the-flag>#</a></h2><p>Now that we have <code>d</code>, we can get the flag by simply running the below script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.Util.number <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>k <span style=color:#f92672>=</span> pow(c1, d, n)
</span></span><span style=display:flex><span>K <span style=color:#f92672>=</span> pow(g, k, a)
</span></span><span style=display:flex><span>print long_to_bytes(c2 <span style=color:#f92672>*</span> inverse(K, a) <span style=color:#f92672>%</span> a)
</span></span></code></pre></div><p><strong>Flag</strong>: ASIS{Wiener_at7ack_iN_mUlt1_Prim3_RSA_iZ_f34sible_t0O!}</p><p>You can read the full solution script <a href=https://github.com/ashutosh1206/Crypto-CTF-Writeups/blob/master/2017/ASIS-CTF-Finals/Gracias/exploit.py>here</a></p><hr><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ol><li><a href=https://gist.github.com/niklasb/84fb894c7658f29b21fd7b7e1704f799>Niklasb&rsquo;s solution</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://ashutosh1206.github.io/tags/rsa/>RSA</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ashutosh1206.github.io/>Ashutosh Ahelleya</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>