<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Crypto writeups [Part-1] - InCTFi 2018 | Ash&#39;s blog</title>
<meta name="keywords" content="RSA, Coppersmith">
<meta name="description" content="InCTF is over and I must say that we enjoyed a lot! We stayed for two days straight in front of our laptop screens, sleep deprived, fixing services, solving queries on IRC, eating and what not! My experience organising InCTF-2018, creating crypto challenges, how I came across the idea of creating all the crypto challenges etc. is another blog post I have to write soon, let us jump to what is in scope of this blog post.">
<meta name="author" content="Ashutosh Ahelleya">
<link rel="canonical" href="https://ashutosh1206.github.io/ctf/inctfi18-crypto-part1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ashutosh1206.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashutosh1206.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashutosh1206.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashutosh1206.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashutosh1206.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<meta property="og:title" content="Crypto writeups [Part-1] - InCTFi 2018" />
<meta property="og:description" content="InCTF is over and I must say that we enjoyed a lot! We stayed for two days straight in front of our laptop screens, sleep deprived, fixing services, solving queries on IRC, eating and what not! My experience organising InCTF-2018, creating crypto challenges, how I came across the idea of creating all the crypto challenges etc. is another blog post I have to write soon, let us jump to what is in scope of this blog post." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ashutosh1206.github.io/ctf/inctfi18-crypto-part1/" /><meta property="article:section" content="ctf" />
<meta property="article:published_time" content="2018-10-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-10-11T00:00:00+00:00" /><meta property="og:site_name" content="Ash&#39;s blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Crypto writeups [Part-1] - InCTFi 2018"/>
<meta name="twitter:description" content="InCTF is over and I must say that we enjoyed a lot! We stayed for two days straight in front of our laptop screens, sleep deprived, fixing services, solving queries on IRC, eating and what not! My experience organising InCTF-2018, creating crypto challenges, how I came across the idea of creating all the crypto challenges etc. is another blog post I have to write soon, let us jump to what is in scope of this blog post."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Ctfs",
      "item": "https://ashutosh1206.github.io/ctf/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Crypto writeups [Part-1] - InCTFi 2018",
      "item": "https://ashutosh1206.github.io/ctf/inctfi18-crypto-part1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Crypto writeups [Part-1] - InCTFi 2018",
  "name": "Crypto writeups [Part-1] - InCTFi 2018",
  "description": "InCTF is over and I must say that we enjoyed a lot! We stayed for two days straight in front of our laptop screens, sleep deprived, fixing services, solving queries on IRC, eating and what not! My experience organising InCTF-2018, creating crypto challenges, how I came across the idea of creating all the crypto challenges etc. is another blog post I have to write soon, let us jump to what is in scope of this blog post.",
  "keywords": [
    "RSA", "Coppersmith"
  ],
  "articleBody": "InCTF is over and I must say that we enjoyed a lot! We stayed for two days straight in front of our laptop screens, sleep deprived, fixing services, solving queries on IRC, eating and what not! My experience organising InCTF-2018, creating crypto challenges, how I came across the idea of creating all the crypto challenges etc. is another blog post I have to write soon, let us jump to what is in scope of this blog post.\nWe will also be posting all the challenge source scripts, exploit scripts and write-ups to our team’s GitHub account- https://github.com/teambi0s by next week, so keep checking that!\nThis blog post covers intended solutions of two crypto challenges from InCTF-2018:\nThrowback and baby-Alice-Bob.\nThrowback Challenge Description\nThis was the first and a warmup crypto challenge for InCTF International-2018. In this challenge you are given a ciphertext file ciphertext.txt, encryption script encryptRSA.py, and a public key file public.pem.\nLet us see the contents of encryptRSA.py:\nfrom Crypto.PublicKey import RSA from Crypto.Util.number import * key = RSA.importKey(open(\"public.pem\").read()) n = key.n e = key.e flag = bytes_to_long(open(\"flag.txt\").read()) ct = long_to_bytes(pow(flag, e, n)) open(\"ciphertext.txt\",'w').write(ct) Nothing suspicious, flag file is being encrypted in unpadded RSA using the public key. Let us have a look at the values of public key parameters, which we can get using the following python code:\nfrom Crypto.PublicKey import RSA key = RSA.importKey(open(\"public.pem\").read()) n = key.n e = key.e print n, e Running the above script gives values of public key parameters:\nn = 698491229018617866913439446346471163472558208924077226680142788666975310538145321929146447762905069894035917431326487956250957720571978572823687849059920787303025692154070829036217928749360678725398133415179255935742309941010132694576977689456112119629015193398461689794498824641575321133336366067022953975900092198038260902623522501246578776626162635825107771722711940199404818420573142581587276540226521274722941752974216982918201384775694541078556882367813031L e = 473942956098597820220469792845742500778787667370139945336962851836944820611758016955838474056135974449429651523689707189746956503090573007038882592192662108009105988801240992546857461015645973313376512628146439789647175954429224823945115651118751480270762628324283169644336180720618427405011551606650256747631187135571937711488876112426342905154035663354772248678642559769320890564854022113441429962294088612832697262354998514171764811530183386631750738577941129L Hmm, looks like Wiener’s Attack? No it isn’t. Try it! And does not give any output on running RSACtfTool too. As we know that Wiener’s Attack works when \\(d \u003c N^\\frac{1}{4}\\).\nTo understand the attack used in this challenge, it would be great if you know the internals of Wiener’s Attack which you can read here: https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener. Now, assuming that you now know the internals of Wiener’s Attack, let us head towards the attack in this challenge.\nThere is a cool attack, known as a variant of Wiener’s Attack on RSA, which works in cases when \\(d\\) is a few bits greater than \\(N^\\frac{1}{4}\\). Here is a paper on it by Andrej Dujella: https://www.math.tugraz.at/~cecc08/abstracts/cecc08_abstract_20.pdf\nI have also explained and implemented the attack in my library Crypton here: https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener-variant. In short, variant of Wiener’s Attack on RSA states that in case \\(d\\) is a few bits greater than \\(N^\\frac{1}{4}\\), candidates for private key are of the form:\n$$rq_{m+1} + sq_m$$\nwhere \\(q_{m+1}\\) and \\(q_{m}\\) are (m+1)th and (m)th convergent of continued fraction of \\(\\frac{e}{n}\\).\nImplementation of the attack in python/sage:\nfrom sage.all import * def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() q1 = i.denominator() for r in range(30): for s in range(30): d = r*q1 + s*q0 m1 = pow(c, d, n) if m1 == m: return d q0 = q1 return None wiener(e, n) Ran the script for around 1 and a half minute to get \\(d\\): 101163513230017858871883136800341227994997965012215130183396962583124452930473\nNow, we can get the flag by simply decrypting the ciphertext using the private key we just obtained:\nfrom Crypto.Util.number import * from Crypto.PublicKey import RSA ct = bytes_to_long(open(\"ciphertext.txt\").read()) d = 101163513230017858871883136800341227994997965012215130183396962583124452930473 key = RSA.importKey(open(\"public.pem\").read()) print long_to_bytes(pow(ct, d, key.n)) Which gives us the flag: inctf{w4rmup_sh0uld_b3_wi3n3r_bu7_ext3nd3d}! Voila!\nI guess even Boneh Durfee attack can solve this challenge, but this attack is much shorter and easier to implement 🙂\nLet me know your feedback on InCTF-2018 crypto challenges by pinging me on Twitter, or in the comments section!\nThis was the second challenge that was given for InCTF-2018. In this challenge you are given two ciphertext files ciphertext1.txt and ciphertext2.txt, encryption script encrypt.py, and two public key files publickey1.pem and publickey2.pem.\nLet us analyse encrypt.py:\n#!/usr/bin/env python2.7 from Crypto.PublicKey import RSA from Crypto.Util.number import * import gmpy2 import sys def get_e(N, p, q): e = getRandomInteger(30) while GCD(e, (p-1)*(q-1)) == 1: e += 1 assert GCD(e, (p-1)*(q-1)) != 1 return e def prima(p): while not isPrime(p): p += 1 assert isPrime(p) return p def gen_publickey(sz): while True: coeff = getRandomInteger(5) p = getPrime(1024) q = coeff*p + getRandomInteger(512) p = prima(p) print \"size(p): \", size(p) q = prima(q) print \"size(q): \", size(q) print \"\" N = p*q e = get_e(N, p, q) return (e, N, p, q) e1, N1, p1, q1 = gen_publickey(1024) e2, N2, p2, q2 = gen_publickey(1024) # Exporting private key for admin priv_key = RSA.construct((N1, e1, None, p1, q1)) priv_key2 = RSA.construct((N2, e2, None, p2, q2)) open(\"privatekey1.pem\",\"w\").write(priv_key.exportKey(\"PEM\")) open(\"privatekey2.pem\",\"w\").write(priv_key2.exportKey(\"PEM\")) # Exporting public keys pub_key = RSA.construct((N1, e1)) pub_key2 = RSA.construct((N2, e2)) open(\"publickey1.pem\",\"w\").write(pub_key.exportKey(\"PEM\")) open(\"publickey2.pem\",\"w\").write(pub_key2.exportKey(\"PEM\")) flag = open(\"flag.txt\",'r').read() flag_num = bytes_to_long(flag) ct1 = pow(flag_num, e1, N1) ct2 = pow(flag_num, e2, N2) print \"ciphertext1: \", ct1 print \"ciphertext2: \", ct2 f1 = open(\"ciphertext1.txt\", 'w') f2 = open(\"ciphertext2.txt\", 'w') f1.write(long_to_bytes(ct1)) f2.write(long_to_bytes(ct2)) Some peculiar things to notice in this script:\n​​​​​The two ciphertext files ciphertext1.txt and ciphertext2.txt are encrypted form of the same message. get_e(N, p, q) function: e returned from this function satisfies the following condition: ​GCD(e, (p-1)*(q-1)) != 1. This implies that we cannot calculate \\(e^{-1}\\mod (p-1)*(q-1)\\) and hence \\(d\\) cannot be calculated directly. gen_publickey() function: something interesting - primes are related: p = getPrime(1024) q = getRandomInteger(5)*p + getRandomInteger(512) p = prima(p) q = prima(q) They are not so close to allow Fermat’s Factorisation, and getRandomInteger(512) function is not pseudo-random. Hence, we cannot do anything with that. getRandomInteger(5) generates numbers upto 32, so that can be bruteforced, remember that. But one question that arises is: why two public keys? We don’t know that yet.\nLet us approximate the values of \\(p\\) and \\(q\\) and see if we can find anything:\npapprox can be written as \\(N^\\frac{1}{i}\\) where ​i is a brute-force iterator from 1-32. Upper bound for qapprox (maximum possible value) can be written as \\(i*papprox + 2^{512}\\) Now that we have an upper bound for \\(​​q\\). If we make a univariate polynomial over modulo \\(N\\), for \\(P(x) = x - qapprox\\) , from Coppersmith’s theorem we know that we can find small roots of this polynomial efficiently to get \\(x\\) and then calculate ​\\(q\\) as qapprox (upper bound) - x. This will give us one of the factors of \\(N\\)! Voila! We implement the same in sage/python (Similar to https://github.com/p4-team/ctf/tree/master/2017-09-02-tokyo/crypto_rsa):\nfrom sage.all import * n = sys.argv[1] e = sys.argv[2] for i in range(1, 32): div = int(n/i) papprox = isqrt(div) qapprox = i*papprox + 2**512 F. = PolynomialRing(Zmod(n)) f = x - qapprox d = f.small_roots(X=2**512, beta=0.5) if d: d = d[0] print qapprox - d break The above script gives us one factor each from \\(N_1\\) (publickey modulus from publickey1.pem) and \\(N_2\\) (publickey modulus from publickey2.pem), let us say they are \\(q_1\\) and \\(q_2\\) respectively.\nq1 = 3807106592404975601125033090180503344264174569255897409284423052897092445417674962362221548320775037781978870632221456368716628390293018864172214774714465531462065303179649214122810035176785416262624632995978331814185099550531145861149188438984893130980572838590794755709091002422200644150512364254454557260789 q2 = 2751296681586435626720222057380271100763911689072786354291138095461126286215853115732617512578076591584325152559069002543980487680247274388725342124525719292925128397536955722536120578433729304047954769670529111876899791612062118642496846657307745240072073877747762856779534078553583788593091249350529237188097 We can calculate \\(p_1\\) and \\(p_2\\) as: \\(\\frac{N_1}{q_1}\\) and \\(\\frac{N_2}{q_2}\\) respectively.\nWhat after this? Remember, we cannot directly calculate decryption \\(d\\) from \\(e\\), \\(p\\), \\(q\\) due to reasons mentioned earlier. Why did the author give two ciphertext files and two pairs of public keys? Maybe we can use this somewhere? Moving on to the second and final level:\nNotice that \\(GCD(e_1, p_1-1) = 1\\), where \\(e_1\\) is the encryption exponent of the first public key- publickey1.pem. Also, \\(GCD(e_2, p_2-1) = 1\\), where \\(e_2\\) is the encryption exponent of the second public key- ​publickey2.pem. Umm, sounds like some progress? We probably have to do something with this…\nWe can calculate \\(m\\mod p_1\\) from \\(ct_1\\) (ciphertext in ciphertext1.txt) as: By Euler’s Theorem, we can write:\nI made sure that \\(m\\) is not less than \\(p_1\\) 😉\nSo you cannot directly get \\(m\\) from here, you will have to use the second key as well 😉\nNow that we have \\(m\\mod p_1\\), we can do the same calculations as above to get \\(m\\mod p_2\\):\nWe now have \\(m\\mod p_1\\) and \\(m\\mod p_2\\). We can now use CRT to calculate \\(m\\mod p_1*p_2\\). Ofcourse, now we can get ​​m (Try to think why!)\nI wrote the following script in python that computes necessary operations discussed above and then CRT to give the flag!\nfrom Crypto.PublicKey import RSA from Crypto.Util.number import * def crt(list_a, list_m): for i in range(len(list_m)): for j in range(len(list_m)): if GCD(list_m[i], list_m[j])!= 1 and i!=j: return None M = 1 for i in list_m: M *= i list_b = [M/i for i in list_m] assert len(list_b) == len(list_m) list_b_inv = [inverse(list_b[i], list_m[i]) for i in range(len(list_m))] x = 0 for i in range(len(list_m)): x += list_a[i]*list_b[i]*list_b_inv[i] return x % M key1 = RSA.importKey(open(\"publickey1.pem\").read()) key2 = RSA.importKey(open(\"publickey2.pem\").read()) N1 = key1.n e1 = key1.e N2 = key2.n e2 = key2.e ct1 = bytes_to_long(open(\"ciphertext1.txt\").read()) ct2 = bytes_to_long(open(\"ciphertext2.txt\").read()) q1 = 3807106592404975601125033090180503344264174569255897409284423052897092445417674962362221548320775037781978870632221456368716628390293018864172214774714465531462065303179649214122810035176785416262624632995978331814185099550531145861149188438984893130980572838590794755709091002422200644150512364254454557260789 assert N1 % q1 == 0 p1 = N1 / q1 q2 = 2751296681586435626720222057380271100763911689072786354291138095461126286215853115732617512578076591584325152559069002543980487680247274388725342124525719292925128397536955722536120578433729304047954769670529111876899791612062118642496846657307745240072073877747762856779534078553583788593091249350529237188097 assert N2 % q2 == 0 p2 = N2 / q2 assert GCD(e1, (p1-1)) == 1 assert GCD(e2, (p2-1)) == 1 d1 = inverse(e1, (p1-1)) d2 = inverse(e2, (p2-1)) print \"d1: \", d1 print \"d2: \", d2 a1 = pow(ct1, d1, p1) a2 = pow(ct2, d2, p2) print long_to_bytes(crt([a1, a2], [p1, p2])) Running the above script gives us the flag: inctf{s4y_hell0_2_c0pp3rsm1th_\u0026_CRT}! Voila! You must have understood by now why we need two ciphertext files, two public keys to solve this challenge! Go ahead and read the description of this challenge again 😉\nHope you enjoyed solving my challenges! I have to post writeups of 3 more crypto challenges which will be out soon! If you have any feedback or query regarding any of the crypto challenges from InCTF-2018, you can ping me on Twitter or comment in the comments section below!\n",
  "wordCount" : "1603",
  "inLanguage": "en",
  "datePublished": "2018-10-11T00:00:00Z",
  "dateModified": "2018-10-11T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Ashutosh Ahelleya"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashutosh1206.github.io/ctf/inctfi18-crypto-part1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ash's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashutosh1206.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashutosh1206.github.io/" accesskey="h" title="Home (Alt + H)">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashutosh1206.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://ashutosh1206.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://ashutosh1206.github.io/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://ashutosh1206.github.io/ctf/" title="CTF">
                    <span>CTF</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Crypto writeups [Part-1] - InCTFi 2018
    </h1>
    <div class="post-meta"><span title='2018-10-11 00:00:00 +0000 UTC'>October 11, 2018</span>&nbsp;·&nbsp;Ashutosh Ahelleya

</div>
  </header> 
  <div class="post-content"><p>InCTF is over and I must say that we enjoyed a lot! We stayed for two days straight in front of our laptop screens, sleep deprived, fixing services, solving queries on IRC, eating and what not! My experience organising InCTF-2018, creating crypto challenges, how I came across the idea of creating all the crypto challenges etc. is another blog post I have to write soon, let us jump to what is in scope of this blog post.</p>
<p>We will also be posting all the challenge source scripts, exploit scripts and write-ups to our team’s GitHub account- <a href="https://github.com/teambi0s">https://github.com/teambi0s</a> by next week, so keep checking that!</p>
<p>This blog post covers intended solutions of two crypto challenges from InCTF-2018:<br>
Throwback and baby-Alice-Bob.</p>
<!-- raw HTML omitted -->
<h1 id="throwback">Throwback<a hidden class="anchor" aria-hidden="true" href="#throwback">#</a></h1>
<p><img loading="lazy" src="/inctfi18-crypto-part1-1.png" alt="picture"  />
<br>
<em>Challenge Description</em></p>
<p>This was the first and a warmup crypto challenge for InCTF International-2018. In this challenge you are given a ciphertext file <code>ciphertext.txt</code>, encryption script <code>encryptRSA.py</code>, and a public key file <code>public.pem</code>.</p>
<p>Let us see the contents of <code>encryptRSA.py</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> RSA
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>importKey(open(<span style="color:#e6db74">&#34;public.pem&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span>n
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span>e
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> bytes_to_long(open(<span style="color:#e6db74">&#34;flag.txt&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>ct <span style="color:#f92672">=</span> long_to_bytes(pow(flag, e, n))
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#34;ciphertext.txt&#34;</span>,<span style="color:#e6db74">&#39;w&#39;</span>)<span style="color:#f92672">.</span>write(ct)
</span></span></code></pre></div><p>Nothing suspicious, flag file is being encrypted in unpadded RSA using the public key. Let us have a look at the values of public key parameters, which we can get using the following python code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> RSA
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>importKey(open(<span style="color:#e6db74">&#34;public.pem&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span>n
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span>e
</span></span><span style="display:flex;"><span>print n, e
</span></span></code></pre></div><p>Running the above script gives values of public key parameters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">698491229018617866913439446346471163472558208924077226680142788666975310538145321929146447762905069894035917431326487956250957720571978572823687849059920787303025692154070829036217928749360678725398133415179255935742309941010132694576977689456112119629015193398461689794498824641575321133336366067022953975900092198038260902623522501246578776626162635825107771722711940199404818420573142581587276540226521274722941752974216982918201384775694541078556882367813031</span>L
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> <span style="color:#ae81ff">473942956098597820220469792845742500778787667370139945336962851836944820611758016955838474056135974449429651523689707189746956503090573007038882592192662108009105988801240992546857461015645973313376512628146439789647175954429224823945115651118751480270762628324283169644336180720618427405011551606650256747631187135571937711488876112426342905154035663354772248678642559769320890564854022113441429962294088612832697262354998514171764811530183386631750738577941129</span>L
</span></span></code></pre></div><p>Hmm, looks like <a href="https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener">Wiener’s Attack</a>? No it isn’t. Try it! And does not give any output on running <a href="https://github.com/Ganapati/RsaCtfTool">RSACtfTool</a> too. As we know that Wiener’s Attack works when \(d &lt; N^\frac{1}{4}\).</p>
<p>To understand the attack used in this challenge, it would be great if you know the internals of Wiener’s Attack which you can read here: <a href="https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener">https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener</a>. Now, assuming that you now know the internals of Wiener’s Attack, let us head towards the attack in this challenge.</p>
<p>There is a cool attack, known as a variant of Wiener’s Attack on RSA, which works in cases when \(d\) is a few bits greater than \(N^\frac{1}{4}\). Here is a paper on it by Andrej Dujella: <a href="https://www.math.tugraz.at/~cecc08/abstracts/cecc08_abstract_20.pdf">https://www.math.tugraz.at/~cecc08/abstracts/cecc08_abstract_20.pdf</a></p>
<p>I have also explained and implemented the attack in my library Crypton here: <a href="https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener-variant">https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-Wiener-variant</a>. In short, variant of Wiener’s Attack on RSA states that in case \(d\) is a few bits greater than \(N^\frac{1}{4}\), candidates for private key are of the form:</p>
<p>$$rq_{m+1} + sq_m$$</p>
<p>where \(q_{m+1}\) and \(q_{m}\) are (m+1)th and (m)th convergent of continued fraction of \(\frac{e}{n}\).</p>
<p>Implementation of the attack in python/sage:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> sage.all <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wiener</span>(e, n):
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> pow(m, e, n)
</span></span><span style="display:flex;"><span>    q0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list1 <span style="color:#f92672">=</span> continued_fraction(Integer(e)<span style="color:#f92672">/</span>Integer(n))
</span></span><span style="display:flex;"><span>    conv <span style="color:#f92672">=</span> list1<span style="color:#f92672">.</span>convergents()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> conv:
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>numerator()
</span></span><span style="display:flex;"><span>        q1 <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>denominator()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">30</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">30</span>):
</span></span><span style="display:flex;"><span>                d <span style="color:#f92672">=</span> r<span style="color:#f92672">*</span>q1 <span style="color:#f92672">+</span> s<span style="color:#f92672">*</span>q0
</span></span><span style="display:flex;"><span>                m1 <span style="color:#f92672">=</span> pow(c, d, n)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> m1 <span style="color:#f92672">==</span> m:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>        q0 <span style="color:#f92672">=</span> q1
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>wiener(e, n)
</span></span></code></pre></div><p>Ran the script for around 1 and a half minute to get \(d\): 101163513230017858871883136800341227994997965012215130183396962583124452930473</p>
<p>Now, we can get the flag by simply decrypting the ciphertext using the private key we just obtained:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> RSA
</span></span><span style="display:flex;"><span>ct <span style="color:#f92672">=</span> bytes_to_long(open(<span style="color:#e6db74">&#34;ciphertext.txt&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>d <span style="color:#f92672">=</span> <span style="color:#ae81ff">101163513230017858871883136800341227994997965012215130183396962583124452930473</span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>importKey(open(<span style="color:#e6db74">&#34;public.pem&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>print long_to_bytes(pow(ct, d, key<span style="color:#f92672">.</span>n))
</span></span></code></pre></div><p>Which gives us the flag: <strong>inctf{w4rmup_sh0uld_b3_wi3n3r_bu7_ext3nd3d}</strong>! Voila!</p>
<p>I guess even Boneh Durfee attack can solve this challenge, but this attack is much shorter and easier to implement 🙂</p>
<p>Let me know your feedback on InCTF-2018 crypto challenges by <a href="https://twitter.com/ashutosha_">pinging me on Twitter</a>, or in the comments section!</p>
<!-- raw HTML omitted -->
<p>This was the second challenge that was given for InCTF-2018. In this challenge you are given two ciphertext files <code>ciphertext1.txt</code> and <code>ciphertext2.txt</code>, encryption script <code>encrypt.py</code>, and two public key files <code>publickey1.pem</code> and <code>publickey2.pem</code>.</p>
<p>Let us analyse <code>encrypt.py</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python2.7</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> RSA
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> gmpy2
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_e</span>(N, p, q):
</span></span><span style="display:flex;"><span>    e <span style="color:#f92672">=</span> getRandomInteger(<span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> GCD(e, (p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>(q<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        e <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> GCD(e, (p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>(q<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prima</span>(p):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> isPrime(p):
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> isPrime(p)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gen_publickey</span>(sz):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        coeff <span style="color:#f92672">=</span> getRandomInteger(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> getPrime(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>        q <span style="color:#f92672">=</span> coeff<span style="color:#f92672">*</span>p <span style="color:#f92672">+</span> getRandomInteger(<span style="color:#ae81ff">512</span>)
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> prima(p)
</span></span><span style="display:flex;"><span>        print <span style="color:#e6db74">&#34;size(p): &#34;</span>, size(p)
</span></span><span style="display:flex;"><span>        q <span style="color:#f92672">=</span> prima(q)
</span></span><span style="display:flex;"><span>        print <span style="color:#e6db74">&#34;size(q): &#34;</span>, size(q)
</span></span><span style="display:flex;"><span>        print <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        N <span style="color:#f92672">=</span> p<span style="color:#f92672">*</span>q
</span></span><span style="display:flex;"><span>        e <span style="color:#f92672">=</span> get_e(N, p, q)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (e, N, p, q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>e1, N1, p1, q1 <span style="color:#f92672">=</span> gen_publickey(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>e2, N2, p2, q2 <span style="color:#f92672">=</span> gen_publickey(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Exporting private key for admin</span>
</span></span><span style="display:flex;"><span>priv_key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>construct((N1, e1, <span style="color:#66d9ef">None</span>, p1, q1))
</span></span><span style="display:flex;"><span>priv_key2 <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>construct((N2, e2, <span style="color:#66d9ef">None</span>, p2, q2))
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#34;privatekey1.pem&#34;</span>,<span style="color:#e6db74">&#34;w&#34;</span>)<span style="color:#f92672">.</span>write(priv_key<span style="color:#f92672">.</span>exportKey(<span style="color:#e6db74">&#34;PEM&#34;</span>))
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#34;privatekey2.pem&#34;</span>,<span style="color:#e6db74">&#34;w&#34;</span>)<span style="color:#f92672">.</span>write(priv_key2<span style="color:#f92672">.</span>exportKey(<span style="color:#e6db74">&#34;PEM&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Exporting public keys</span>
</span></span><span style="display:flex;"><span>pub_key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>construct((N1, e1))
</span></span><span style="display:flex;"><span>pub_key2 <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>construct((N2, e2))
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#34;publickey1.pem&#34;</span>,<span style="color:#e6db74">&#34;w&#34;</span>)<span style="color:#f92672">.</span>write(pub_key<span style="color:#f92672">.</span>exportKey(<span style="color:#e6db74">&#34;PEM&#34;</span>))
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#34;publickey2.pem&#34;</span>,<span style="color:#e6db74">&#34;w&#34;</span>)<span style="color:#f92672">.</span>write(pub_key2<span style="color:#f92672">.</span>exportKey(<span style="color:#e6db74">&#34;PEM&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#39;r&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>flag_num <span style="color:#f92672">=</span> bytes_to_long(flag)
</span></span><span style="display:flex;"><span>ct1 <span style="color:#f92672">=</span> pow(flag_num, e1, N1)
</span></span><span style="display:flex;"><span>ct2 <span style="color:#f92672">=</span> pow(flag_num, e2, N2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print <span style="color:#e6db74">&#34;ciphertext1: &#34;</span>, ct1
</span></span><span style="display:flex;"><span>print <span style="color:#e6db74">&#34;ciphertext2: &#34;</span>, ct2
</span></span><span style="display:flex;"><span>f1 <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;ciphertext1.txt&#34;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)
</span></span><span style="display:flex;"><span>f2 <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;ciphertext2.txt&#34;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)
</span></span><span style="display:flex;"><span>f1<span style="color:#f92672">.</span>write(long_to_bytes(ct1))
</span></span><span style="display:flex;"><span>f2<span style="color:#f92672">.</span>write(long_to_bytes(ct2))
</span></span></code></pre></div><p>Some peculiar things to notice in this script:</p>
<ol>
<li>​​​​​The two ciphertext files <code>ciphertext1.txt</code> and <code>ciphertext2.txt</code> are encrypted form of the same message.</li>
<li><code>get_e(N, p, q)</code> function:  e returned from this function satisfies the following condition: ​GCD(e, (p-1)*(q-1)) != 1.  This implies that we cannot calculate \(e^{-1}\mod (p-1)*(q-1)\) and hence \(d\) cannot be calculated directly.</li>
<li><code>gen_publickey()</code> function: something interesting - primes are related:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>p <span style="color:#f92672">=</span> getPrime(<span style="color:#ae81ff">1024</span>)  
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> getRandomInteger(<span style="color:#ae81ff">5</span>)<span style="color:#f92672">*</span>p <span style="color:#f92672">+</span> getRandomInteger(<span style="color:#ae81ff">512</span>)  
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> prima(p)  
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> prima(q)  
</span></span></code></pre></div><ul>
<li>They are not so close to allow Fermat’s Factorisation, and <code>getRandomInteger(512)</code> function is not pseudo-random. Hence, we cannot do anything with that.</li>
<li><code>getRandomInteger(5)</code> generates numbers upto 32, so that can be bruteforced, remember that.</li>
</ul>
<p>But one question that arises is: why two public keys? We don’t know that yet.</p>
<p>Let us approximate the values of \(p\) and \(q\) and see if we can find anything:</p>
<ol>
<li><code>papprox</code> can be written as \(N^\frac{1}{i}\) where ​<code>i</code> is a brute-force iterator from 1-32.</li>
<li>Upper bound for <code>qapprox</code> (maximum possible value) can be written as \(i*papprox + 2^{512}\)</li>
<li>Now that we have an upper bound for \(​​q\). If we make a univariate polynomial over modulo \(N\), for \(P(x) = x - qapprox\) , from Coppersmith’s theorem we know that we can find small roots of this polynomial efficiently to get \(x\) and then calculate ​\(q\) as qapprox (upper bound) - x. This will give us one of the factors of \(N\)! Voila!</li>
</ol>
<p>We implement the same in sage/python (Similar to <a href="https://github.com/p4-team/ctf/tree/master/2017-09-02-tokyo/crypto_rsa)">https://github.com/p4-team/ctf/tree/master/2017-09-02-tokyo/crypto_rsa)</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> sage.all <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">32</span>):
</span></span><span style="display:flex;"><span>    div <span style="color:#f92672">=</span> int(n<span style="color:#f92672">/</span>i)
</span></span><span style="display:flex;"><span>    papprox <span style="color:#f92672">=</span> isqrt(div)
</span></span><span style="display:flex;"><span>    qapprox <span style="color:#f92672">=</span> i<span style="color:#f92672">*</span>papprox <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">512</span>
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">.</span> <span style="color:#f92672">=</span> PolynomialRing(Zmod(n))
</span></span><span style="display:flex;"><span>    f <span style="color:#f92672">=</span> x <span style="color:#f92672">-</span> qapprox
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>small_roots(X<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">512</span>, beta<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> d:
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> d[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        print qapprox <span style="color:#f92672">-</span> d
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span></code></pre></div><p>The above script gives us one factor each from \(N_1\) (publickey modulus from publickey1.pem) and \(N_2\) (publickey modulus from publickey2.pem), let us say they are \(q_1\) and \(q_2\) respectively.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>q1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3807106592404975601125033090180503344264174569255897409284423052897092445417674962362221548320775037781978870632221456368716628390293018864172214774714465531462065303179649214122810035176785416262624632995978331814185099550531145861149188438984893130980572838590794755709091002422200644150512364254454557260789</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2751296681586435626720222057380271100763911689072786354291138095461126286215853115732617512578076591584325152559069002543980487680247274388725342124525719292925128397536955722536120578433729304047954769670529111876899791612062118642496846657307745240072073877747762856779534078553583788593091249350529237188097</span>
</span></span></code></pre></div><p>We can calculate \(p_1\) and \(p_2\) as: \(\frac{N_1}{q_1}\) and \(\frac{N_2}{q_2}\) respectively.</p>
<p>What after this? Remember, we cannot directly calculate decryption \(d\) from \(e\), \(p\), \(q\) due to reasons mentioned earlier. Why did the author give two ciphertext files and two pairs of public keys? Maybe we can use this somewhere? Moving on to the second and final level:</p>
<p>Notice that \(GCD(e_1, p_1-1) = 1\), where \(e_1\) is the encryption exponent of the first public key- <code>publickey1.pem</code>. Also, \(GCD(e_2, p_2-1) = 1\), where \(e_2\) is the encryption exponent of the second public key- <code>​publickey2.pem</code>. Umm, sounds like some progress? We probably have to do something with this&hellip;</p>
<p>We can calculate \(m\mod p_1\) from \(ct_1\) (ciphertext in <code>ciphertext1.txt</code>) as:
<img loading="lazy" src="/inctfi18-crypto-part1-3.gif" alt="picture"  />
</p>
<p>By Euler&rsquo;s Theorem, we can write:<br>
<img loading="lazy" src="/inctfi18-crypto-part1-4.gif" alt="picture"  />
</p>
<p>I made sure that \(m\) is not less than \(p_1\) 😉<br>
So you cannot directly get \(m\) from here, you will have to use the second key as well 😉</p>
<p>Now that we have \(m\mod p_1\), we can do the same calculations as above to get \(m\mod p_2\):<br>
<img loading="lazy" src="/inctfi18-crypto-part1-5.gif" alt="picture"  />
</p>
<p>We now have \(m\mod p_1\) and \(m\mod p_2\). We can now use CRT to calculate \(m\mod p_1*p_2\). Ofcourse, now we can get ​​<code>m</code> (Try to think why!)</p>
<p>I wrote the following script in python that computes necessary operations discussed above and then CRT to give the flag!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> RSA
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">crt</span>(list_a, list_m):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(list_m)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(list_m)):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> GCD(list_m[i], list_m[j])<span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> i<span style="color:#f92672">!=</span>j:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    M <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> list_m:
</span></span><span style="display:flex;"><span>        M <span style="color:#f92672">*=</span> i
</span></span><span style="display:flex;"><span>    list_b <span style="color:#f92672">=</span> [M<span style="color:#f92672">/</span>i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> list_m]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> len(list_b) <span style="color:#f92672">==</span> len(list_m)
</span></span><span style="display:flex;"><span>    list_b_inv <span style="color:#f92672">=</span> [inverse(list_b[i], list_m[i]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(list_m))]
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(list_m)):
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">+=</span> list_a[i]<span style="color:#f92672">*</span>list_b[i]<span style="color:#f92672">*</span>list_b_inv[i]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">%</span> M
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>key1 <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>importKey(open(<span style="color:#e6db74">&#34;publickey1.pem&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>key2 <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>importKey(open(<span style="color:#e6db74">&#34;publickey2.pem&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>N1 <span style="color:#f92672">=</span> key1<span style="color:#f92672">.</span>n
</span></span><span style="display:flex;"><span>e1 <span style="color:#f92672">=</span> key1<span style="color:#f92672">.</span>e
</span></span><span style="display:flex;"><span>N2 <span style="color:#f92672">=</span> key2<span style="color:#f92672">.</span>n
</span></span><span style="display:flex;"><span>e2 <span style="color:#f92672">=</span> key2<span style="color:#f92672">.</span>e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ct1 <span style="color:#f92672">=</span> bytes_to_long(open(<span style="color:#e6db74">&#34;ciphertext1.txt&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>ct2 <span style="color:#f92672">=</span> bytes_to_long(open(<span style="color:#e6db74">&#34;ciphertext2.txt&#34;</span>)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3807106592404975601125033090180503344264174569255897409284423052897092445417674962362221548320775037781978870632221456368716628390293018864172214774714465531462065303179649214122810035176785416262624632995978331814185099550531145861149188438984893130980572838590794755709091002422200644150512364254454557260789</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> N1 <span style="color:#f92672">%</span> q1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>p1 <span style="color:#f92672">=</span> N1 <span style="color:#f92672">/</span> q1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2751296681586435626720222057380271100763911689072786354291138095461126286215853115732617512578076591584325152559069002543980487680247274388725342124525719292925128397536955722536120578433729304047954769670529111876899791612062118642496846657307745240072073877747762856779534078553583788593091249350529237188097</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> N2 <span style="color:#f92672">%</span> q2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>p2 <span style="color:#f92672">=</span> N2 <span style="color:#f92672">/</span> q2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> GCD(e1, (p1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> GCD(e2, (p2<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d1 <span style="color:#f92672">=</span> inverse(e1, (p1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>d2 <span style="color:#f92672">=</span> inverse(e2, (p2<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>print <span style="color:#e6db74">&#34;d1: &#34;</span>, d1
</span></span><span style="display:flex;"><span>print <span style="color:#e6db74">&#34;d2: &#34;</span>, d2
</span></span><span style="display:flex;"><span>a1 <span style="color:#f92672">=</span> pow(ct1, d1, p1)
</span></span><span style="display:flex;"><span>a2 <span style="color:#f92672">=</span> pow(ct2, d2, p2)
</span></span><span style="display:flex;"><span>print long_to_bytes(crt([a1, a2], [p1, p2]))
</span></span></code></pre></div><p>Running the above script gives us the flag: <strong>inctf{s4y_hell0_2_c0pp3rsm1th_&amp;_CRT}</strong>! Voila! You must have understood by now why we need two ciphertext files, two public keys to solve this challenge! Go ahead and read the description of this challenge again 😉</p>
<p>Hope you enjoyed solving my challenges! I have to post writeups of 3 more crypto challenges which will be out soon! If you have any feedback or query regarding any of the crypto challenges from InCTF-2018, you can <a href="https://twitter.com/ashutosha_">ping me on Twitter</a> or comment in the comments section below!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashutosh1206.github.io/tags/rsa/">RSA</a></li>
      <li><a href="https://ashutosh1206.github.io/tags/coppersmith/">Coppersmith</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ashutosh1206.github.io/">Ash&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
