<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>USSH 3.0 - CTFZone | Ash&#39;s blog</title>
<meta name="keywords" content="BlockCipher, CBC-Bit-Flipping">
<meta name="description" content="Challenge Points: 138
Challenge Description:
We&rsquo;ve developed a new restricted shell. It also allows to manage user access more securely. Let&rsquo;s try it
nc crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one 1337
In this post, I will be discussing my solution for USSH-3.0 challenge from CTFZone which I think is the unintended way. The challenge was quite peculiar, involving “blind” exploit as you will see in this write-up. Some parts of the challenge might look like guessing, but if you read this write-up start-to-end, you will see that it was a well-tailored challenge.">
<meta name="author" content="Ashutosh Ahelleya">
<link rel="canonical" href="https://ashutosh1206.github.io/ctf/ctfzone18-ussh/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ashutosh1206.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashutosh1206.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashutosh1206.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashutosh1206.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashutosh1206.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<meta property="og:title" content="USSH 3.0 - CTFZone" />
<meta property="og:description" content="Challenge Points: 138
Challenge Description:
We&rsquo;ve developed a new restricted shell. It also allows to manage user access more securely. Let&rsquo;s try it
nc crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one 1337
In this post, I will be discussing my solution for USSH-3.0 challenge from CTFZone which I think is the unintended way. The challenge was quite peculiar, involving “blind” exploit as you will see in this write-up. Some parts of the challenge might look like guessing, but if you read this write-up start-to-end, you will see that it was a well-tailored challenge." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ashutosh1206.github.io/ctf/ctfzone18-ussh/" /><meta property="article:section" content="ctf" />
<meta property="article:published_time" content="2018-07-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-07-23T00:00:00+00:00" /><meta property="og:site_name" content="Ash&#39;s blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="USSH 3.0 - CTFZone"/>
<meta name="twitter:description" content="Challenge Points: 138
Challenge Description:
We&rsquo;ve developed a new restricted shell. It also allows to manage user access more securely. Let&rsquo;s try it
nc crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one 1337
In this post, I will be discussing my solution for USSH-3.0 challenge from CTFZone which I think is the unintended way. The challenge was quite peculiar, involving “blind” exploit as you will see in this write-up. Some parts of the challenge might look like guessing, but if you read this write-up start-to-end, you will see that it was a well-tailored challenge."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Ctfs",
      "item": "https://ashutosh1206.github.io/ctf/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "USSH 3.0 - CTFZone",
      "item": "https://ashutosh1206.github.io/ctf/ctfzone18-ussh/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "USSH 3.0 - CTFZone",
  "name": "USSH 3.0 - CTFZone",
  "description": "Challenge Points: 138\nChallenge Description:\nWe\u0026rsquo;ve developed a new restricted shell. It also allows to manage user access more securely. Let\u0026rsquo;s try it\nnc crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one 1337\nIn this post, I will be discussing my solution for USSH-3.0 challenge from CTFZone which I think is the unintended way. The challenge was quite peculiar, involving “blind” exploit as you will see in this write-up. Some parts of the challenge might look like guessing, but if you read this write-up start-to-end, you will see that it was a well-tailored challenge.",
  "keywords": [
    "BlockCipher", "CBC-Bit-Flipping"
  ],
  "articleBody": "Challenge Points: 138\nChallenge Description:\nWe’ve developed a new restricted shell. It also allows to manage user access more securely. Let’s try it\nnc crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one 1337\nIn this post, I will be discussing my solution for USSH-3.0 challenge from CTFZone which I think is the unintended way. The challenge was quite peculiar, involving “blind” exploit as you will see in this write-up. Some parts of the challenge might look like guessing, but if you read this write-up start-to-end, you will see that it was a well-tailored challenge.\nAlso, this write-up is a timeline of my progress throughout the challenge- key observations, patterns that helped me move forward in the challenge and finally helped me make a payload that got me the flag!\nSo let us dive into the challenge details: We are provided with a service running on crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one and port number 1337. On accessing the service using nc gives: We are allowed to login using any username (see the limits on the username below). We are also assigned a group- regular to restrict permissions.\nSome observations from the above pictures:\nWe cannot login with username admin​ or root. Because login with that username will give us privileges to something in the service that we don’t know yet at this point of time in the challenge.\nAfter logging in, we get a shell kind-of interface where we can supply commands \u0026 if the command is recognised, it will be executed. Quickly going through commands- help​, id​, session, exit, ls​, cat.\nGiving ls as the input gives us the output shown below. There are 3 files- flag.txt, info.txt, ​backup.sh. As the name suggests, flag.txt file contains the flag.\nWe can use the cat command to display the contents of any of the 3 files. We will try to display the contents of flag.txt because that is what seems to be the motive of this challenge. Feeding this command gives us: We need to be of group root, to read this file (We don’t have permission to change our group, as it is done by the service. We are only allowed to give the username as the input). We will try displaying contents of other files: Nothing that could be of help. So that seems a dead end. Let us try out other commands.\nid – shows the permissions of the user to which we are logged in session – shows the base64 encoded session cookie, in a format we know nothing about. It also allows us to set a valid cookie, if we have it. All these findings, helped me clear the objective of the challenge\nLogin as admin by getting it’s cookie Set the group as root. At the current stage of solving the challenge, we still don’t know how the cookie is being generated. The only possible way to exploit the service would be to somehow know the format of the cookie and also how it is generated.\nThere is nothing else in the service, that could lead us to the admin login and root privileges except the cookie information.\nExploring the session cookie This is how a cookie looks like in the challenge: This looks like two base64 encoded strings concatenated using a separator ‘:’ (colon), so let us check the contents and the length of these strings, to see what we can get: Nothing in the content of these strings, but notice their lengths? They are a multiple of 16, reminds me of block cipher!\nObservations: I tried the same giving different input strings, noting each of their lengths, and observed that no matter how long our login name is, the first part of the cookie (ie. the part before “:”), is always 16. Also, the length of the second part of the cookie depends on our input— the longer our input is, longer will be the length of the second part of the cookie.\nConclusions/Speculations: I speculated that the first part of the cookie could be the Initialisation Vector for a CBC encrypted plaintext (of an unknown format, which contains our username somewhere), the ciphertext of which is the second part of the cookie.\nBut we need that our speculation is correct, so let us play around with the cookie’s first part.\nRemember that if the blocksize of a block cipher is 16 then it’s IV has to be of length 16 as well.\nWe can use this property to check if the cookie is really encrypted using CBC mode or not. All we have to do is modify the cookie by setting it’s first part of length!=16. If the service shows an error, then our assumption is certainly correct. I just removed last byte from the first part of the cookie to check for any errors and fortunately I got one.\nNow that we certainly know that the cookie is being generated using a block cipher in CBC mode, we need to strengthen our assumption further, so let us try changing the length in the second part of the ciphertext too. We can also try changing the last byte in the second part of the cookie. (Note that the last byte in the ciphertext is the padding byte, so the service should throw a padding error if we change it’s value). Slowly, the case scenario is getting clearer. We now know:\nThe cookie format (It consists of two strings separated by a colon) The service is using a block cipher in CBC mode to encrypt the plaintext. Plaintext is padded using PKCS#7 What we do not know: The contents and orientation of the plaintext before getting encrypted to generate the cookie Location of the username in plaintext string Let us find out what we do not know!\nFinding plaintext format of the cookie Decryption in CBC mode:\nThe easiest way to check this is by modifying the IV by one byte such that we notice change in some byte of the username. As soon as we notice this, we get the index at which that flipped byte of the username is present, which can then be used to trace the location of our username in the plaintext.\nWe did it the same way- I changed the 11th index (12th character) of IV and noticed a changed in the 3rd character of my username: We can use this to trace the positioning of our username- 12th character in IV changes 3rd character of our username implies that our username starts from 10th character in the plaintext version of the cookie.\nIf I try to change any other index in IV other than the indices occupied by our username, the service throws an authentication error.\nPlaying with the username - CBC Bit Flipping Since the cookie is encrypted using CBC mode of encryption, we can flip IV bytes to get a username of our choice. Check out my blog post to read more about CBC Bit Flipping Attack.\nI did a similar thing on the service; logged in as admun, flipped ‘u’ to ‘i’ and got the cookie for admin: Although we are able to login as admin, it still doesn’t give us the flag because cookie also contains the group to which a username belongs and it can only show the contents of flag.txt for users belonging to the root group :(\nAfter this, I talked to the admin and he told me that the group is present after username in the cookie. So we got another lead, we surely have to work on it!\nImportant: One thing to notice is that, group=root could be in the second block of plaintext and that we will have to flip some bytes in the first block of ciphertext to change corresponding bytes in the plaintext. Flipping even a single byte in the first block of ciphertext could lead to scrambling of the entire first block of plaintext (because block cipher!). This makes the task of flipping even more difficult (Check this challenge, if you want to test your Bit Flipping skills- CNVService- ACEBEAR CTF 2018)\nTowards developing payload In every challenge, I always try to find some unusual solution to a challenge that makes things simpler. Same was the case with this challenge.\nOur sole motive now that remains, is to exploit the authentication mechanism. Through some experience of solving challenges based on CBC Bit Flipping Attacks, I have now gained some knowledge of how authentication in most of the vuln services work. If you want to solve more challenges based on the same vuln, make sure you check out the following challenges:\nCNVService: ACEBEAR CTF 2018 Level-21: websec.fr Let us see what could be the possible auth mechanism:\nService separates IV and the ciphertext by splitting the cookie from the separator (which is a colon in our challenge)\nDecrypts the ciphertext using key and iv, gets the plaintext\nThere could be a possible special character separating the username and the group (For most vuln servers it is username and password).\nThe first step in authentication is to split the plaintext into username and group using this special character acting as a separator.\nThe server then has two decrypted parts:\nFirst part: contains username= Second part: contains group= (You must be wondering why “group=” only and why not any other format? Because the error message in some case itself says “Permission denied, expect group=root” –\u003e Check any of the above pictures to observe this) Server auth mechanism:\nFirst check: The server would then check if the first 9 bytes of the first part of the plaintext equal “username=”, if not, then it straightaway throws a VerificationError. If yes, then it moves to next step. (Why 9 bytes? Remember that when we were finding the index at which our username was located, we found it to be starting from 10th byte, the string prior to our username must be “username=”!).\nAfter first check holds true, the server would store any subsequent characters of first part of the plaintext that come after “username=” as the actual username (for example: testuser, admun etc.).\nSecond check: The server would then check if the first 6 bytes of the second part of the plaintext equal “group=”, if not, then it straightaway throws a VerificationError. If yes, then it moves to the next step.\nAfter second check holds true, the server would store any subsequent characters of the second part of the plaintext that come after “group=” as the group to which the username belongs (for example: regular, root) (Remember that in our challenge there exist only two groups: regular and root, so any other group other than these two would throw a VerificationError)\nThird check: Server checks if the padding is valid or not. Not of interest as of now (we can come back to testing vulnerability here, if the next exploit doesn’t work)\nOnly after all the checks pass, does the service allow us to login using the username and group that it obtained from the previous steps.\nExploiting python split() function implementation For the auth mechanism above, the service would mostly split the plaintext as follows (Assuming that the character separating username and the group is “:” used only for illustration):\nlist1 = plaintext.split(\":\") username = list1[0] group = list1[1] Note that if there are multiple occurrences of “:” (ie. the separator), the above command would ignore any other “:” characters except it’s first occurrence! See this example to understand it better: (Observe the above picture carefully!)\nWhat if we introduce this separator in the plaintext itself? Won’t that result in ignoring other occurrences of the separator and hence the string after the second “:” (This string is group=regular)? Yes, it will!\nWe can give the same username as the one just shown above: admin:group=root to get root access and also login as admin! We are very close to getting the flag!\nBut, not everything comes so easy:\nWe don’t know the separator separating username and it’s group Even if we know the separator, we won’t be able to login using ​admin:group=root, because login does not allow special characters in the input. Adding special characters to the username This is fairly easy, as we can login as ​adminkgroup=root and then flip 6th byte of the username from ‘k’ to the separator. Note that 6th byte in the username corresponds to 15th byte (14th index) in the IV according to our payload login username: adminkgroup=root.\nFinding the separator I wrote the following script to brute force all the special characters. We can do this by registering under username adminkgroup=root and then flip ‘k’ with a special character in each iteration and check if username to which we are logged in is exactly equal to ​admin or not. This happens because as soon as we get the correct separator, our exploit will work and we will be able to login as admin, otherwise the service would simply log us in with username admin++group=root.\nfrom pwn import * import string def session_flip(iv, index, present_char, flip_char): assert len(present_char) == 1 assert len(flip_char) == 1 session = iv[:index] + chr(ord(iv[index]) ^ ord(present_char) ^ ord(flip_char)) + iv[index+1:] return session.encode(\"base64\").strip() possible_chars = string.punctuation r = remote(\"crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one\",\"1337\") print r.recvuntil(\"Login:\") r.sendline(\"adminkgroup=root\") print r.recvuntil(\"@crypto: $ \") r.sendline(\"session --get\") str1 = r.recvline(\"@crypto: $ \") str1 = str1.strip() \"\"\" Session cookie consists of two parts: IV and the ciphertext, separated by a some character `a` that we are going to find out by brute force \"\"\" print str1 iv, ciphertext = str1.split(\":\") print \"iv: \", iv print \"ciphertext: \", ciphertext iv = iv.decode(\"base64\") for i in possible_chars: r.sendline(\"session --set \" + session_flip(iv, 14, 'k', i)+\":\"+ciphertext) temp = r.recvuntil(\"@crypto: $ \") print \"sent: \" + i + \" \" + temp Running this script gave me the following output: Notice that our exploit works for one particular special character- ‘\u0026’\nNow that we have everything, let us give input as adminkgroup=root and flip ‘k‘ with ‘\u0026‘ to get the flag! Wrote the following script to flip characters:\ndef session_flip(iv, index, present_char, flip_char): assert len(present_char) == 1 assert len(flip_char) == 1 session = iv[:index] + chr(ord(iv[index]) ^ ord(present_char) ^ ord(flip_char)) + iv[index+1:] return session.encode(\"base64\") input_str = raw_input(\"Enter the base64 cookie: \") str1, str2 = input_str.split(\":\") str1 = str1.decode(\"base64\") print session_flip(str1, 14, 'k','\u0026').strip() + \":\" + str2 This gives us: Found the flag! I thoroughly enjoyed solving this challenge!\nWe (team bi0s) – https://ctftime.org/team/662 stood 19th in this CTF!\nThis post is a bit long, so if you have some doubts or have found some mistake, feel free to post it in the comments or reach me out on Twitter!\n",
  "wordCount" : "2424",
  "inLanguage": "en",
  "datePublished": "2018-07-23T00:00:00Z",
  "dateModified": "2018-07-23T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Ashutosh Ahelleya"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashutosh1206.github.io/ctf/ctfzone18-ussh/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ash's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashutosh1206.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashutosh1206.github.io/" accesskey="h" title="Home (Alt + H)">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashutosh1206.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://ashutosh1206.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://ashutosh1206.github.io/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://ashutosh1206.github.io/ctf/" title="CTF">
                    <span>CTF</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      USSH 3.0 - CTFZone
    </h1>
    <div class="post-meta"><span title='2018-07-23 00:00:00 +0000 UTC'>July 23, 2018</span>&nbsp;·&nbsp;Ashutosh Ahelleya

</div>
  </header> 
  <div class="post-content"><p><strong>Challenge Points</strong>: 138<br>
<strong>Challenge Description</strong>:</p>
<blockquote>
<p>We&rsquo;ve developed a new restricted shell. It also allows to manage user access more securely. Let&rsquo;s try it<br>
<code>nc crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one 1337</code></p>
</blockquote>
<p>In this post, I will be discussing my solution for USSH-3.0 challenge from CTFZone which I think is the unintended way. The challenge was quite peculiar, involving “blind” exploit as you will see in this write-up. Some parts of the challenge might look like guessing, but if you read this write-up start-to-end, you will see that it was a well-tailored challenge.</p>
<p>Also, this write-up is a timeline of my progress throughout the challenge- key observations, patterns that helped me move forward in the challenge and finally helped me make a payload that got me the flag!</p>
<p>So let us dive into the challenge details:
We are provided with a service running on <code>crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one</code> and port number <code>1337</code>. On accessing the service using nc gives:
<img loading="lazy" src="/ctfzone18-ussh-1.png" alt="picture"  />

<img loading="lazy" src="/ctfzone18-ussh-2.png" alt="picture"  />
</p>
<p>We are allowed to login using any username (see the limits on the username below). We are also assigned a group- <strong>regular</strong> to restrict permissions.</p>
<p>Some observations from the above pictures:</p>
<ol>
<li>
<p>We cannot login with username <code>admin​</code> or <code>root</code>.  Because login with that username will give us privileges to something in the service that we don’t know yet at this point of time in the challenge.</p>
</li>
<li>
<p>After logging in, we get a <em>shell</em> kind-of interface where we can supply commands &amp; if the command is recognised, it will be executed. Quickly going through commands- <code>help​</code>, <code>id</code>​, <code>session</code>, <code>exit</code>, <code>ls​</code>, <code>cat</code>.</p>
</li>
</ol>
<ul>
<li>
<p>Giving <code>ls</code> as the input gives us the output shown below. There are 3 files- flag.txt, info.txt, ​backup.sh. As the name suggests, flag.txt file contains the flag.</p>
</li>
<li>
<p>We can use the <code>cat</code> command to display the contents of any of the 3 files. We will try to display the contents of flag.txt because that is what seems to be the motive of this challenge. Feeding this command gives us: <img loading="lazy" src="/ctfzone18-ussh-3.png" alt="picture"  />
 We need to be of group <strong>root</strong>, to read this file (We don’t have permission to change our group, as it is done by the service. We are only allowed to give the username as the input). We will try displaying contents of other files: <img loading="lazy" src="/ctfzone18-ussh-4.png" alt="picture"  />
 Nothing that could be of help. So that seems a dead end. Let us try out other commands.</p>
</li>
<li>
<p><code>id</code> &ndash; shows the permissions of the user to which we are logged in <img loading="lazy" src="/ctfzone18-ussh-5.png" alt="picture"  />
</p>
</li>
<li>
<p><code>session</code> &ndash; shows the base64 encoded session cookie, in a format we know nothing about. It also allows us to set a valid cookie, if we have it. <img loading="lazy" src="/ctfzone18-ussh-6.png" alt="picture"  />
</p>
</li>
</ul>
<p>All these findings, helped me clear the <strong>objective</strong> of the challenge</p>
<ol>
<li><strong>Login as admin</strong> by getting it’s cookie</li>
<li>Set the group as <strong>root</strong>.</li>
</ol>
<p>At the current stage of solving the challenge, we still don’t know how the cookie is being generated. The only possible way to exploit the service would be to somehow know the format of the cookie and also how it is generated.</p>
<p>There is nothing else in the service, that could lead us to the admin login and root privileges except the cookie information.</p>
<h2 id="exploring-the-session-cookie">Exploring the session cookie<a hidden class="anchor" aria-hidden="true" href="#exploring-the-session-cookie">#</a></h2>
<p>This is how a cookie looks like in the challenge: <img loading="lazy" src="/ctfzone18-ussh-7.png" alt="picture"  />
</p>
<p>This looks like two base64 encoded strings concatenated using a separator ‘:’ (colon), so let us check the contents and the length of these strings, to see what we can get:
<img loading="lazy" src="/ctfzone18-ussh-8.png" alt="picture"  />
</p>
<p>Nothing in the content of these strings, but notice their lengths? They are a multiple of 16, reminds me of block cipher!</p>
<p><strong>Observations</strong>: I tried the same giving different input strings, noting each of their lengths, and observed that no matter how long our login name is, the first part of the cookie (ie. the part before “:”), is always 16. Also, the length of the second part of the cookie depends on our input&mdash; the longer our input is, longer will be the length of the second part of the cookie.</p>
<p><strong>Conclusions/Speculations</strong>: I speculated that the first part of the cookie could be the Initialisation Vector for a CBC encrypted plaintext (of an unknown format, which contains our username somewhere), the ciphertext of which is the second part of the cookie.</p>
<p>But we need that our speculation is correct, so let us play around with the cookie’s first part.</p>
<ol>
<li>
<p>Remember that if the blocksize of a block cipher is 16 then it’s IV has to be of length 16 as well.</p>
</li>
<li>
<p>We can use this property to check if the cookie is really encrypted using CBC mode or not. All we have to do is modify the cookie by setting it’s first part of length!=16. If the service shows an error, then our assumption is certainly correct. <img loading="lazy" src="/ctfzone18-ussh-9.png" alt="picture"  />
<br>
I just removed last byte from the first part of the cookie to check for any errors and fortunately I got one.</p>
</li>
<li>
<p>Now that we certainly know that the cookie is being generated using a block cipher in CBC mode, we need to strengthen our assumption further, so let us try changing the length in the second part of the ciphertext too. We can also try changing the last byte in the second part of the cookie. (Note that the last byte in the ciphertext is the padding byte, so the service should throw a padding error if we change it’s value). <img loading="lazy" src="/ctfzone18-ussh-10.png" alt="picture"  />
</p>
</li>
<li>
<p>Slowly, the case scenario is getting clearer. We now know:</p>
</li>
</ol>
<ul>
<li>The cookie format (It consists of two strings separated by a colon)</li>
<li>The service is using a block cipher in CBC mode to encrypt the plaintext.</li>
<li>Plaintext is padded using PKCS#7</li>
</ul>
<ol start="5">
<li>What we do not know:</li>
</ol>
<ul>
<li>The contents and orientation of the plaintext before getting encrypted to generate the cookie</li>
<li>Location of the username in plaintext string</li>
</ul>
<p>Let us find out what we do not know!</p>
<h2 id="finding-plaintext-format-of-the-cookie">Finding plaintext format of the cookie<a hidden class="anchor" aria-hidden="true" href="#finding-plaintext-format-of-the-cookie">#</a></h2>
<p>Decryption in CBC mode:<br>
<img loading="lazy" src="/ctfzone18-ussh-11.png" alt="picture"  />
</p>
<p>The easiest way to check this is by modifying the IV by one byte such that we notice change in some byte of the username. As soon as we notice this, we get the index at which that flipped byte of the username is present, which can then be used to trace the location of our username in the plaintext.</p>
<p>We did it the same way- I changed the 11th index (12th character) of IV and noticed a changed in the 3rd character of my username:
<img loading="lazy" src="/ctfzone18-ussh-12.png" alt="picture"  />
</p>
<p>We can use this to trace the <strong>positioning</strong> of our username- 12th character in IV changes 3rd character of our username implies that our username starts from 10th character in the plaintext version of the cookie.</p>
<p>If I try to change any other index in IV other than the indices occupied by our username, the service throws an authentication error.</p>
<h2 id="playing-with-the-username---cbc-bit-flipping">Playing with the username - CBC Bit Flipping<a hidden class="anchor" aria-hidden="true" href="#playing-with-the-username---cbc-bit-flipping">#</a></h2>
<p>Since the cookie is encrypted using CBC mode of encryption, we can flip IV bytes to get a username of our choice. Check out my <a href="https://masterpessimistaa.wordpress.com/2017/05/03/cbc-bit-flipping-attack/">blog post</a> to read more about CBC Bit Flipping Attack.</p>
<p>I did a similar thing on the service; logged in as admun, flipped ‘u’ to ‘i’ and got the cookie for admin:
<img loading="lazy" src="/ctfzone18-ussh-13.png" alt="picture"  />
</p>
<p>Although we are able to login as admin, it still doesn’t give us the flag because cookie also contains the group to which a username belongs and it can only show the contents of flag.txt for users belonging to the root group :(</p>
<p>After this, I talked to the admin and he told me that the group is present after username in the cookie. So we got another lead, we surely have to work on it!</p>
<p><strong>Important</strong>: One thing to notice is that, <strong>group=root</strong> could be in the second block of plaintext and that we will have to flip some bytes in the first block of ciphertext to change corresponding bytes in the plaintext.  Flipping even a single byte in the first block of ciphertext could lead to scrambling of the entire first block of plaintext (because block cipher!). This makes the task of flipping even more difficult (Check this challenge, if you want to test your Bit Flipping skills- <a href="https://masterpessimistaa.wordpress.com/2018/01/31/cnvservice-acebear-ctf-2018-writeup/">CNVService- ACEBEAR CTF 2018</a>)</p>
<h2 id="towards-developing-payload">Towards developing payload<a hidden class="anchor" aria-hidden="true" href="#towards-developing-payload">#</a></h2>
<p>In every challenge, I always try to find some unusual solution to a challenge that makes things simpler. Same was the case with this challenge.</p>
<p>Our sole motive now that remains, is to exploit the authentication mechanism. Through some experience of solving challenges based on CBC Bit Flipping Attacks, I have now gained some knowledge of how authentication in most of the vuln services work. If you want to solve more challenges based on the same vuln, make sure you check out the following challenges:</p>
<ol>
<li>CNVService: ACEBEAR CTF 2018</li>
<li>Level-21: <a href="http://websec.fr/">websec.fr</a></li>
</ol>
<p>Let us see what could be the possible auth mechanism:</p>
<ol>
<li>
<p>Service separates IV and the ciphertext by splitting the cookie from the separator (which is a colon in our challenge)</p>
</li>
<li>
<p>Decrypts the ciphertext using key and iv, gets the plaintext</p>
</li>
<li>
<p>There could be a possible special character separating the username and the group (For most vuln servers it is username and password).</p>
</li>
</ol>
<ul>
<li>
<p>The first step in authentication is to split the plaintext into username and group using this special character acting as a separator.</p>
</li>
<li>
<p>The server then has two decrypted parts:</p>
<ul>
<li><em>First part</em>: contains <code>username=</code></li>
<li><em>Second part</em>: contains <code>group=</code> (You must be wondering why “group=” only and why not any other format? Because the error message in some case itself says “Permission denied, expect group=root” –&gt; Check any of the above pictures to observe this)</li>
</ul>
</li>
<li>
<p>Server auth mechanism:</p>
<ul>
<li>
<p><strong>First check</strong>: The server would then check if the first 9 bytes of the first part of the plaintext equal “username=”, if not, then it straightaway throws a VerificationError. If yes, then it moves to next step. (Why 9 bytes? Remember that when we were finding the index at which our username was located, we found it to be starting from 10th byte, the string prior to our username must be “username=”!).</p>
</li>
<li>
<p>After first check holds true, the server would store any subsequent characters of first part of the plaintext that come after “username=” as the actual username (for example: <code>testuser</code>, <code>admun</code> etc.).</p>
</li>
<li>
<p><strong>Second check</strong>: The server would then check if the first 6 bytes of the second part of the plaintext equal “group=”, if not, then it straightaway throws a <code>VerificationError</code>. If yes, then it moves to the next step.</p>
</li>
<li>
<p>After second check holds true, the server would store any subsequent characters of the second part of the plaintext that come after “group=” as the group to which the username belongs (for example: <code>regular</code>, <code>root</code>) (Remember that in our challenge there exist only two groups: regular and root, so any other group other than these two would throw a <code>VerificationError</code>)</p>
</li>
<li>
<p><strong>Third check</strong>: Server checks if the padding is valid or not. Not of interest as of now (we can come back to testing vulnerability here, if the next exploit doesn’t work)</p>
</li>
<li>
<p>Only after all the checks pass, does the service allow us to login using the username and group that it obtained from the previous steps.</p>
</li>
</ul>
</li>
</ul>
<h2 id="exploiting-python-split-function-implementation">Exploiting python split() function implementation<a hidden class="anchor" aria-hidden="true" href="#exploiting-python-split-function-implementation">#</a></h2>
<p>For the auth mechanism above, the service would mostly split the plaintext as follows (Assuming that the character separating username and the group is “:” used only for illustration):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>list1 <span style="color:#f92672">=</span> plaintext<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;:&#34;</span>)
</span></span><span style="display:flex;"><span>username <span style="color:#f92672">=</span> list1[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>group <span style="color:#f92672">=</span> list1[<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>Note that if there are multiple occurrences of “:” (ie. the separator), the above command would ignore any other “:” characters except it’s first occurrence! See this example to understand it better: <img loading="lazy" src="/ctfzone18-ussh-14.png" alt="picture"  />
</p>
<p>(Observe the above picture carefully!)</p>
<p>What if we introduce this separator in the plaintext itself? Won’t that result in ignoring other occurrences of the separator and hence the string after the second “:” (This string is <code>group=regular</code>)? Yes, it will!</p>
<p>We can give the same username as the one just shown above: <code>admin:group=root</code> to get root access and also login as admin! We are very close to getting the flag!</p>
<p>But, not everything comes so easy:</p>
<ol>
<li>We don’t know the separator separating username and it’s group</li>
<li>Even if we know the separator, we won’t be able to login using <code>​admin:group=root</code>, because login does not allow special characters in the input.</li>
</ol>
<h3 id="adding-special-characters-to-the-username">Adding special characters to the username<a hidden class="anchor" aria-hidden="true" href="#adding-special-characters-to-the-username">#</a></h3>
<p>This is fairly easy, as we can login as <code>​adminkgroup=root</code> and then flip 6th byte of the username from ‘k’ to the separator. Note that 6th byte in the username corresponds to 15th byte (14th index) in the IV according to our payload login username: <code>adminkgroup=root</code>.</p>
<h3 id="finding-the-separator">Finding the separator<a hidden class="anchor" aria-hidden="true" href="#finding-the-separator">#</a></h3>
<p>I wrote the following script to brute force all the special characters. We can do this by registering under username <code>adminkgroup=root</code> and then flip ‘k’ with a special character in each iteration and check if username to which we are logged in is exactly equal to <code>​admin</code> or not. This happens because as soon as we get the correct separator, our exploit will work and we will be able to login as admin, otherwise the service would simply log us in with username <code>admin+&lt;special_operator&gt;+group=root</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> string
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">session_flip</span>(iv, index, present_char, flip_char):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> len(present_char) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> len(flip_char) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    session <span style="color:#f92672">=</span> iv[:index] <span style="color:#f92672">+</span> chr(ord(iv[index]) <span style="color:#f92672">^</span> ord(present_char) <span style="color:#f92672">^</span> ord(flip_char)) <span style="color:#f92672">+</span> iv[index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> session<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#34;base64&#34;</span>)<span style="color:#f92672">.</span>strip()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>possible_chars <span style="color:#f92672">=</span> string<span style="color:#f92672">.</span>punctuation
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#34;crypto-01.v7frkwrfyhsjtbpfcppnu.ctfz.one&#34;</span>,<span style="color:#e6db74">&#34;1337&#34;</span>)
</span></span><span style="display:flex;"><span>print r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;Login:&#34;</span>)
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">&#34;adminkgroup=root&#34;</span>)
</span></span><span style="display:flex;"><span>print r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;@crypto: $ &#34;</span>)
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">&#34;session --get&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>str1 <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvline(<span style="color:#e6db74">&#34;@crypto: $ &#34;</span>)
</span></span><span style="display:flex;"><span>str1 <span style="color:#f92672">=</span> str1<span style="color:#f92672">.</span>strip()
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Session cookie consists of two parts: IV and the ciphertext,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">separated by a some character `a` that we are going to find out by brute force
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>print str1
</span></span><span style="display:flex;"><span>iv, ciphertext <span style="color:#f92672">=</span> str1<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;:&#34;</span>)
</span></span><span style="display:flex;"><span>print <span style="color:#e6db74">&#34;iv: &#34;</span>, iv
</span></span><span style="display:flex;"><span>print <span style="color:#e6db74">&#34;ciphertext: &#34;</span>, ciphertext
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iv <span style="color:#f92672">=</span> iv<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;base64&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> possible_chars:
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">&#34;session --set &#34;</span> <span style="color:#f92672">+</span> session_flip(iv, <span style="color:#ae81ff">14</span>, <span style="color:#e6db74">&#39;k&#39;</span>, i)<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;:&#34;</span><span style="color:#f92672">+</span>ciphertext)
</span></span><span style="display:flex;"><span>    temp <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;@crypto: $ &#34;</span>)
</span></span><span style="display:flex;"><span>    print <span style="color:#e6db74">&#34;sent: &#34;</span> <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> temp
</span></span></code></pre></div><p>Running this script gave me the following output:
<img loading="lazy" src="/ctfzone18-ussh-15.png" alt="picture"  />
</p>
<p>Notice that our exploit works for one particular special character- ‘&amp;’</p>
<p>Now that we have everything, let us give input as <code>adminkgroup=root</code> and flip ‘k‘ with ‘&amp;‘ to get the flag! Wrote the following script to flip characters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">session_flip</span>(iv, index, present_char, flip_char):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> len(present_char) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> len(flip_char) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    session <span style="color:#f92672">=</span> iv[:index] <span style="color:#f92672">+</span> chr(ord(iv[index]) <span style="color:#f92672">^</span> ord(present_char) <span style="color:#f92672">^</span> ord(flip_char)) <span style="color:#f92672">+</span> iv[index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> session<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#34;base64&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>input_str <span style="color:#f92672">=</span> raw_input(<span style="color:#e6db74">&#34;Enter the base64 cookie: &#34;</span>)
</span></span><span style="display:flex;"><span>str1, str2 <span style="color:#f92672">=</span> input_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;:&#34;</span>)
</span></span><span style="display:flex;"><span>str1 <span style="color:#f92672">=</span> str1<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;base64&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print session_flip(str1, <span style="color:#ae81ff">14</span>, <span style="color:#e6db74">&#39;k&#39;</span>,<span style="color:#e6db74">&#39;&amp;&#39;</span>)<span style="color:#f92672">.</span>strip() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> str2
</span></span></code></pre></div><p>This gives us: <img loading="lazy" src="/ctfzone18-ussh-16.png" alt="picture"  />

<img loading="lazy" src="/ctfzone18-ussh-17.png" alt="picture"  />
</p>
<p>Found the flag! I thoroughly enjoyed solving this challenge!<br>
We (team bi0s) – <a href="https://ctftime.org/team/662">https://ctftime.org/team/662</a> stood 19th in this CTF!</p>
<p>This post is a bit long, so if you have some doubts or have found some mistake, feel free to post it in the comments or <a href="https://twitter.com/ashutosha_">reach me out on Twitter</a>!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashutosh1206.github.io/tags/blockcipher/">BlockCipher</a></li>
      <li><a href="https://ashutosh1206.github.io/tags/cbc-bit-flipping/">CBC-Bit-Flipping</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ashutosh1206.github.io/">Ash&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
