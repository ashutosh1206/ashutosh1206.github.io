<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>waRSAw - InCTFi 2019 | Ashutosh Ahelleya</title><meta name=keywords content="numbertheory,rsa"><meta name=description content="Intended solution of waRSAw challenge from InCTF Internationals 2019
tl;dr variant of LSB Oracle Attack on unpadded RSA"><meta name=author content><link rel=canonical href=https://ashutosh1206.github.io/ctf/inctfi19-warsaw/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ashutosh1206.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ashutosh1206.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ashutosh1206.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ashutosh1206.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ashutosh1206.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="waRSAw - InCTFi 2019"><meta property="og:description" content="Intended solution of waRSAw challenge from InCTF Internationals 2019
tl;dr variant of LSB Oracle Attack on unpadded RSA"><meta property="og:type" content="article"><meta property="og:url" content="https://ashutosh1206.github.io/ctf/inctfi19-warsaw/"><meta property="article:section" content="ctf"><meta property="article:published_time" content="2019-09-29T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="waRSAw - InCTFi 2019"><meta name=twitter:description content="Intended solution of waRSAw challenge from InCTF Internationals 2019
tl;dr variant of LSB Oracle Attack on unpadded RSA"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Ctfs","item":"https://ashutosh1206.github.io/ctf/"},{"@type":"ListItem","position":2,"name":"waRSAw - InCTFi 2019","item":"https://ashutosh1206.github.io/ctf/inctfi19-warsaw/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"waRSAw - InCTFi 2019","name":"waRSAw - InCTFi 2019","description":"Intended solution of waRSAw challenge from InCTF Internationals 2019\ntl;dr variant of LSB Oracle Attack on unpadded RSA\n","keywords":["numbertheory","rsa"],"articleBody":"Intended solution of waRSAw challenge from InCTF Internationals 2019\ntl;dr variant of LSB Oracle Attack on unpadded RSA\nChallenge Points: 711\nChallenge Solves: 18\nChallenge Author: s0rc3r3r\nPrerequisites:\nRSA Encryption/Decryption LSBit Oracle Attack Challenge Description Introduction This variant of LSB Oracle Attacks is different as compared to the binary search LSB algorithm for recovering plaintext, in terms of time complexity and ability to recover data on session renewal.\nThis attacks works due to leaking of the Least Significant Bit by an unpadded RSA encryption/decryption oracle that enables the adversary to decrypt the ciphertext in len(plaintext) requests to the oracle, where len(plaintext) is the length of plaintext to be decrypted in bits.\nIn this article, we will try to understand the logic and details behind the variant of LSB oracle attack on unpadded RSA and hence solve the challenge waRSAw using the intended solution.\nVariant of LSB Oracle attack Consider the following scenario: We have access to a service that allows us to encrypt/decrypt text using unpadded RSA. The service encrypts/decrypts using its public key and private key respectively. But after decryption, the server only returns the last bit of the plaintext obtained. How can such a service be vulnerable?\nWe have seen in LSBit Oracle Attack that such a service can be exploited and the plaintext can be recovered in \\(log_2{N}\\) requests, provided that the modulus remains the same in all the iterations.\nWe know that the service returns the last bit of decrypted ciphertext ie. $$ (ct^d\\mod n)\\mod 2\\equiv m\\mod 2 $$ where ct is the ciphertext and m is the plaintext.\nHow can we exploit this?\nOne idea is to do some computation on the ciphertext to shift plaintext right by one bit in each iteration, this way we can obtain one bit of plaintext, starting from the from rightmost bit, in each iteration.\nNext step is to implement this idea:\nWe know that any k-bit plaintext m can be written as:\n$$ m = (a_{k-1}*2^{k-1}) + (a_{k-2}*2^{k-2}) + … + (a_{2}*2^{2}) + (a_{1}*2^{1}) + (a_{0}*2^{0}); \\forall a_i \\in \\{ 0,1 \\}$$\nGet the ciphertext you want to decrypt, let us assume that it to be ct and it’s corresponding plaintext to be m Send the same ciphertext to the oracle for decryption and the oracle will return last bit of plaintext i.e. \\(a_0\\) We will now craft our chosen-ciphertext attack to recover all plaintext bits Chosen-Ciphertext Attack Calculate \\( (ct*(2^{-e} \\mod n) \\mod n)^d\\mod 2 \\equiv m*(2^{-1}\\mod n)\\mod 2 \\)\nNote that the inverse of 2 is calculated over mod n and not over mod 2\nFrom the above equation we can write:\n\\( m*(2^{-1}\\mod n)\\mod 2 \\)\n\\( = [(a_{k-1}*2^{k-1}) + (a_{k-2}*2^{k-2}) + … + (a_{2}*2^{2}) + (a_{1}*2^{1}) + (a_{0}*2^{0})]*2^{-1}\\mod 2 \\)\n\\( = [a_1 + (2^1*a_2) + … + (2^{k-2})*a_{k-1}] + (a_0*2^0)*2^{-1} \\)\n\\( \\equiv a_1 + (a_0*2^0)*2^{-1} \\equiv y \\mod 2 \\)\n\\( \\implies y - (a_0*2^{-1})\\equiv a_1\\mod 2 \\)\nNow that we have the value of 2nd last bit of plaintext i.e. \\(a_1\\), we can adopt a similar approach to recover \\(a_2\\)\nCalculate\n\\( (ct*(2^{-2*e} \\mod n) \\mod n)^d\\mod 2 \\equiv m*(2^{-2}\\mod n)\\mod 2 \\)\nFrom the above equation, we can write:\n\\( m*(2^{-2}\\mod n)\\mod 2 \\)\n\\( = [(a_{k-1}*2^{k-1}) + (a_{k-2}*2^{k-2}) + … + (a_{2}*2^{2}) + (a_{1}*2^{1}) + (a_{0}*2^{0})]*2^{-2}\\mod 2 \\)\n\\( = [a_2 + (2^1*a_3) + … + (2^{k-3})*a_{k-1}] + (a_1*2^1 + a_0*2^0)*2^{-2} \\)\n\\( \\equiv a_2 + (a_1*2^1 + a_0*2^0)*2^{-2} \\equiv y \\mod 2 \\)\n\\( \\implies y - (a_1*2^1 + a_0*2^0)*2^{-2}\\equiv a_2\\mod 2 \\)\nWe can generalise this to compute and recover ith bit of plaintext from the end\nCalculate $$ (ct*(2^{-i*e} \\mod n) \\mod n)^d\\mod 2 \\equiv m*(2^{-i}\\mod n)\\mod 2 $$\nFrom the above equation, we can recover \\(a_i\\) as: $$ [(m*(2^{-i}\\mod n)\\mod 2) - (a_{i-1}*2^{i-1}+…+a_1*2^1 + a_0*2^0)*2^{-i}] \\equiv a_i\\mod 2 $$\nWhat if modulus changes during plaintext recovery (Due to service reconnection etc.)? The attacker can still recover the remaining plaintext bits. He/She/They won’t have to start over again in case of a service restart, since some bits of plaintext would have already been covered and the next iteration to recover \\(a_i\\) can be done directly (see the above equation).\nSolving waRSAw using variant of LSB Oracle Attack We implement the above method to solve the challenge:\nfrom Crypto.Util.number import * from Crypto.PublicKey import RSA from pwn import * def _encrypt(message): r.recvuntil(\"choice: \") r.sendline(\"1\") r.recvuntil(\"to encrypt (in hex): \") r.sendline(message.encode(\"hex\")) ct = r.recvline(\"ciphertext (in hex): \").strip()[37:] r.recvline() r.recvline() return ct.decode(\"hex\") def _decrypt(ciphertext): r.recvuntil(\"choice: \") r.sendline(\"2\") r.recvuntil(\"to decrypt (in hex): \") r.sendline(ciphertext.encode(\"hex\")) pt = r.recvline(\"plaintext (in hex): \").strip()[36:] r.recvline() r.recvline() return pt.decode(\"hex\") # r = process(\"./run.sh\") r = remote(\"18.217.237.201\",\"3197\") r.recvline() flag_enc = r.recvline().strip()[31:].decode(\"hex\") N = int(r.recvline().strip()[20:]) r.close() print \"Flag_enc: \", flag_enc.encode(\"hex\") print \"N: \", N # Public exponent e = 65537 \"\"\" 1. The least significant bit of the flag is 1 2. Can be known by simply sending the ciphertext of the flag to the decryption oracle \"\"\" flag = \"1\" for i in range(1, 400): # r = process(\"./run.sh\") r = remote(\"18.217.237.201\",\"3197\") r.recvline() flag_enc = r.recvline().strip()[31:].decode(\"hex\") N = int(r.recvline().strip()[20:]) # Actual Attack inv = inverse(2**i, N) chosen_ct = long_to_bytes((bytes_to_long(flag_enc)*pow(inv, e, N)) % N) output = _decrypt(chosen_ct) assert output == \"\\x01\" or output == \"\\x00\" flag_char = (ord(output) - (int(flag, 2)*inv) % N) % 2 print \"Here: \", flag_char flag = str(flag_char) + flag if len(flag) % 8 == 0: print long_to_bytes(int(flag, 2)) r.close() Running the above script gives us the flag: inctf{w0w_$0_coOl_LSbit_|3r0}\nIn case of any query, feedback or suggestion, feel free to comment or reach me out on Twitter!\n","wordCount":"924","inLanguage":"en","datePublished":"2019-09-29T00:00:00Z","dateModified":"2019-09-29T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ashutosh1206.github.io/ctf/inctfi19-warsaw/"},"publisher":{"@type":"Organization","name":"Ashutosh Ahelleya","logo":{"@type":"ImageObject","url":"https://ashutosh1206.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ashutosh1206.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ashutosh1206.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ashutosh1206.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://ashutosh1206.github.io/ctf/ title=CTF><span>CTF</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>waRSAw - InCTFi 2019</h1><div class=post-meta><span title='2019-09-29 00:00:00 +0000 UTC'>September 29, 2019</span></div></header><div class=post-content><p>Intended solution of waRSAw challenge from InCTF Internationals 2019</p><p>tl;dr variant of LSB Oracle Attack on unpadded RSA</p><p><strong>Challenge Points</strong>: 711<br><strong>Challenge Solves</strong>: 18<br><strong>Challenge Author</strong>: <a href=https://twitter.com/ashutosha_>s0rc3r3r</a></p><p><strong>Prerequisites</strong>:</p><ol><li><a href=https://github.com/ashutosh1206/Crypton/blob/master/RSA-encryption/README.md>RSA Encryption/Decryption</a></li><li><a href=https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-LSBit-Oracle/README.md>LSBit Oracle Attack</a></li></ol><h2 id=challenge-description>Challenge Description<a hidden class=anchor aria-hidden=true href=#challenge-description>#</a></h2><p></p><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>This variant of LSB Oracle Attacks is different as compared to the binary search LSB algorithm for recovering plaintext, in terms of time complexity and ability to recover data on session renewal.</p><p>This attacks works due to leaking of the Least Significant Bit by an unpadded RSA encryption/decryption oracle that enables the adversary to decrypt the ciphertext in <code>len(plaintext)</code> requests to the oracle, where <code>len(plaintext)</code> is the length of plaintext to be decrypted in bits.</p><p>In this article, we will try to understand the logic and details behind the variant of LSB oracle attack on unpadded RSA and hence solve the challenge waRSAw using the intended solution.</p><h2 id=variant-of-lsb-oracle-attack>Variant of LSB Oracle attack<a hidden class=anchor aria-hidden=true href=#variant-of-lsb-oracle-attack>#</a></h2><p>Consider the following <strong>scenario</strong>: We have access to a service that allows us to encrypt/decrypt text using unpadded RSA. The service encrypts/decrypts using its public key and private key respectively. But after decryption, the server only returns the last bit of the plaintext obtained. How can such a service be vulnerable?</p><p>We have seen in <a href=https://github.com/ashutosh1206/Crypton/tree/master/RSA-encryption/Attack-LSBit-Oracle/README.md>LSBit Oracle Attack</a> that such a service can be exploited and the plaintext can be recovered in \(log_2{N}\) requests, provided that the modulus remains the same in all the iterations.</p><p>We know that the service returns the last bit of decrypted ciphertext ie.
$$ (ct^d\mod n)\mod 2\equiv m\mod 2 $$
where <code>ct</code> is the ciphertext and <code>m</code> is the plaintext.</p><p>How can we exploit this?</p><blockquote><p>One idea is to do some computation on the ciphertext to shift plaintext right by one bit in each iteration, this way we can obtain one bit of plaintext, starting from the from rightmost bit, in each iteration.</p></blockquote><p>Next step is to implement this idea:<br>We know that any <code>k</code>-bit plaintext <code>m</code> can be written as:</p><p>$$ m = (a_{k-1}*2^{k-1}) + (a_{k-2}*2^{k-2}) + &mldr; + (a_{2}*2^{2}) + (a_{1}*2^{1}) + (a_{0}*2^{0}); \forall a_i \in \{ 0,1 \}$$</p><ol><li>Get the ciphertext you want to decrypt, let us assume that it to be <code>ct</code> and it&rsquo;s corresponding plaintext to be <code>m</code></li><li>Send the same ciphertext to the oracle for decryption and the oracle will return last bit of plaintext i.e. \(a_0\)</li><li>We will now craft our chosen-ciphertext attack to recover all plaintext bits</li></ol><h3 id=chosen-ciphertext-attack>Chosen-Ciphertext Attack<a hidden class=anchor aria-hidden=true href=#chosen-ciphertext-attack>#</a></h3><p>Calculate \( (ct*(2^{-e} \mod n) \mod n)^d\mod 2 \equiv m*(2^{-1}\mod n)\mod 2 \)</p><blockquote><p>Note that the inverse of 2 is calculated over <code>mod n</code> and not over <code>mod 2</code></p></blockquote><p>From the above equation we can write:<br>\( m*(2^{-1}\mod n)\mod 2 \)<br>\( = [(a_{k-1}*2^{k-1}) + (a_{k-2}*2^{k-2}) + &mldr; + (a_{2}*2^{2}) + (a_{1}*2^{1}) + (a_{0}*2^{0})]*2^{-1}\mod 2 \)<br>\( = [a_1 + (2^1*a_2) + &mldr; + (2^{k-2})*a_{k-1}] + (a_0*2^0)*2^{-1} \)<br>\( \equiv a_1 + (a_0*2^0)*2^{-1} \equiv y \mod 2 \)<br>\( \implies y - (a_0*2^{-1})\equiv a_1\mod 2 \)</p><p>Now that we have the value of 2nd last bit of plaintext i.e. \(a_1\), we can adopt a similar approach to recover \(a_2\)</p><p>Calculate<br>\( (ct*(2^{-2*e} \mod n) \mod n)^d\mod 2 \equiv m*(2^{-2}\mod n)\mod 2 \)</p><p>From the above equation, we can write:<br>\( m*(2^{-2}\mod n)\mod 2 \)<br>\( = [(a_{k-1}*2^{k-1}) + (a_{k-2}*2^{k-2}) + &mldr; + (a_{2}*2^{2}) + (a_{1}*2^{1}) + (a_{0}*2^{0})]*2^{-2}\mod 2 \)<br>\( = [a_2 + (2^1*a_3) + &mldr; + (2^{k-3})*a_{k-1}] + (a_1*2^1 + a_0*2^0)*2^{-2} \)<br>\( \equiv a_2 + (a_1*2^1 + a_0*2^0)*2^{-2} \equiv y \mod 2 \)<br>\( \implies y - (a_1*2^1 + a_0*2^0)*2^{-2}\equiv a_2\mod 2 \)</p><p>We can generalise this to compute and recover <code>i</code>th bit of plaintext from the end</p><p>Calculate
$$ (ct*(2^{-i*e} \mod n) \mod n)^d\mod 2 \equiv m*(2^{-i}\mod n)\mod 2 $$</p><p>From the above equation, we can recover \(a_i\) as:
$$ [(m*(2^{-i}\mod n)\mod 2) - (a_{i-1}*2^{i-1}+&mldr;+a_1*2^1 + a_0*2^0)*2^{-i}] \equiv a_i\mod 2 $$</p><p><strong>What if modulus changes during plaintext recovery (Due to service reconnection etc.)?</strong> The attacker can still recover the remaining plaintext bits. He/She/They won&rsquo;t have to start over again in case of a service restart, since some bits of plaintext would have already been covered and the next iteration to recover \(a_i\) can be done directly (see the above equation).</p><h2 id=solving-warsaw-using-variant-of-lsb-oracle-attack>Solving waRSAw using variant of LSB Oracle Attack<a hidden class=anchor aria-hidden=true href=#solving-warsaw-using-variant-of-lsb-oracle-attack>#</a></h2><p>We implement the above method to solve the challenge:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.Util.number <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.PublicKey <span style=color:#f92672>import</span> RSA
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_encrypt</span>(message):
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>&#34;choice: &#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>&#34;to encrypt (in hex): &#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>sendline(message<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#34;hex&#34;</span>))
</span></span><span style=display:flex><span>    ct <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>recvline(<span style=color:#e6db74>&#34;ciphertext (in hex): &#34;</span>)<span style=color:#f92672>.</span>strip()[<span style=color:#ae81ff>37</span>:]
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ct<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#34;hex&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_decrypt</span>(ciphertext):
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>&#34;choice: &#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>&#34;2&#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>&#34;to decrypt (in hex): &#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>sendline(ciphertext<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#34;hex&#34;</span>))
</span></span><span style=display:flex><span>    pt <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>recvline(<span style=color:#e6db74>&#34;plaintext (in hex): &#34;</span>)<span style=color:#f92672>.</span>strip()[<span style=color:#ae81ff>36</span>:]
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pt<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#34;hex&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># r = process(&#34;./run.sh&#34;)</span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> remote(<span style=color:#e6db74>&#34;18.217.237.201&#34;</span>,<span style=color:#e6db74>&#34;3197&#34;</span>)
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>flag_enc <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>recvline()<span style=color:#f92672>.</span>strip()[<span style=color:#ae81ff>31</span>:]<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#34;hex&#34;</span>)
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> int(r<span style=color:#f92672>.</span>recvline()<span style=color:#f92672>.</span>strip()[<span style=color:#ae81ff>20</span>:])
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print <span style=color:#e6db74>&#34;Flag_enc: &#34;</span>, flag_enc<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#34;hex&#34;</span>)
</span></span><span style=display:flex><span>print <span style=color:#e6db74>&#34;N: &#34;</span>, N
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Public exponent</span>
</span></span><span style=display:flex><span>e <span style=color:#f92672>=</span> <span style=color:#ae81ff>65537</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>1. The least significant bit of the flag is 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>2. Can be known by simply sending the ciphertext of the flag to the decryption
</span></span></span><span style=display:flex><span><span style=color:#e6db74>oracle
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>400</span>):
</span></span><span style=display:flex><span>    <span style=color:#75715e># r = process(&#34;./run.sh&#34;)</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> remote(<span style=color:#e6db74>&#34;18.217.237.201&#34;</span>,<span style=color:#e6db74>&#34;3197&#34;</span>)
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>    flag_enc <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>recvline()<span style=color:#f92672>.</span>strip()[<span style=color:#ae81ff>31</span>:]<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#34;hex&#34;</span>)
</span></span><span style=display:flex><span>    N <span style=color:#f92672>=</span> int(r<span style=color:#f92672>.</span>recvline()<span style=color:#f92672>.</span>strip()[<span style=color:#ae81ff>20</span>:])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Actual Attack</span>
</span></span><span style=display:flex><span>    inv <span style=color:#f92672>=</span> inverse(<span style=color:#ae81ff>2</span><span style=color:#f92672>**</span>i, N)
</span></span><span style=display:flex><span>    chosen_ct <span style=color:#f92672>=</span> long_to_bytes((bytes_to_long(flag_enc)<span style=color:#f92672>*</span>pow(inv, e, N)) <span style=color:#f92672>%</span> N)
</span></span><span style=display:flex><span>    output <span style=color:#f92672>=</span> _decrypt(chosen_ct)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> output <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x01</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>or</span> output <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    flag_char <span style=color:#f92672>=</span> (ord(output) <span style=color:#f92672>-</span> (int(flag, <span style=color:#ae81ff>2</span>)<span style=color:#f92672>*</span>inv) <span style=color:#f92672>%</span> N) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print <span style=color:#e6db74>&#34;Here: &#34;</span>, flag_char
</span></span><span style=display:flex><span>    flag <span style=color:#f92672>=</span> str(flag_char) <span style=color:#f92672>+</span> flag
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(flag) <span style=color:#f92672>%</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        print long_to_bytes(int(flag, <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    r<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><p>Running the above script gives us the flag: <strong>inctf{w0w_$0_coOl_LSbit_|3r0}</strong></p><p>In case of any query, feedback or suggestion, feel free to comment or <a href=https://twitter.com/ashutosha_>reach me out on Twitter</a>!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ashutosh1206.github.io/tags/numbertheory/>NumberTheory</a></li><li><a href=https://ashutosh1206.github.io/tags/rsa/>RSA</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ashutosh1206.github.io/>Ashutosh Ahelleya</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>